/**************************************************************************
 *
 *  This file is part of the Coin GUI binding libraries.
 *  Copyright (C) 2000 by Systems in Motion.  All rights reserved.
 *
 *  The libraries this file is part of is free software; you can
 *  redistribute them and/or modify them under the terms of the GNU
 *  Lesser General Public License version 2.1 as published by the
 *  Free Software Foundation.  See the file LICENSE.LGPL at the root
 *  directory of the distribution for all the details.
 *
 *  If you want to use the Coin GUI binding libraries for applications
 *  not compatible with the LGPL, contact SIM about acquiring a
 *  Professional Edition License.
 *
 *  Systems in Motion, Prof Brochs gate 6, N-7030 Trondheim, NORWAY
 *  http://www.sim.no/ support@sim.no Voice: +47 22114160 Fax: +47 22207097
 *
 **************************************************************************/

// @configure_input@

#if SOGTK_DEBUG
static const char rcsid[] =
  "";
#endif // SOGTK_DEBUG

/**************************************************************************\
 *
 *  A WORD OF ADVICE
 *
 *  It is fruitless to modify the contents of the SoGtkRenderArea.cpp file
 *  because it is autogenerated by configure from the SoGuiRenderArea.cpp.in
 *  file which you will find in the src/Inventor/Gtk/common/ directory.
 *  Do your modifications to that file instead.
 *
\**************************************************************************/

// *************************************************************************

/*!
  \class SoGtkRenderArea Inventor/Gtk/SoGtkRenderArea.h
  \brief The SoGtkRenderArea class adds scenegraph and event management.
  \ingroup components common

  The SoGtkRenderArea class is a component that adds scenegraph
  management and input device event handling to the SoGtkGLWidget
  component.
*/

// *************************************************************************

#if HAVE_CONFIG_H
#include <config.h>
#endif // HAVE_CONFIG_H

#ifdef SOQT_INTERNAL
#include <qmetaobject.h>
#include <moc_SoQtRenderArea.cpp>
#endif // SOQT_INTERNAL
#if SOQT_DEBUG // For the "soinfo" debugging backdoor.
#include <qgl.h>
#include <qapplication.h>
#endif // SOQT_DEBUG

#include <Inventor/Gtk/common/gl.h> // glDrawBuffer()

#include <Inventor/SoSceneManager.h>
#include <Inventor/events/SoKeyboardEvent.h>
#include <Inventor/errors/SoDebugError.h>
#include <Inventor/misc/SoBasic.h>
#include <Inventor/nodes/SoSelection.h>

#include <sogtkdefs.h>
#include <Inventor/Gtk/SoGtkBasic.h>
#include <Inventor/Gtk/SoGtk.h>
#include <Inventor/Gtk/devices/SoGtkKeyboard.h>
#include <Inventor/Gtk/devices/SoGtkMouse.h>
#include <Inventor/Gtk/devices/SoGtkSpaceball.h>
#ifdef HAVE_JOYSTICK_LINUX
#include <Inventor/Gtk/devices/SoGtkLinuxJoystick.h>
#endif // HAVE_JOYSTICK_LINUX

#include <Inventor/Gtk/SoGtkRenderArea.h>
#include <Inventor/Gtk/SoAny.h>

#include <string.h> // strchr()

#define RENDERAREA_DEBUG_REDRAWS 0

// *************************************************************************

SOGTK_OBJECT_SOURCE(SoGtkRenderArea);

// *************************************************************************

/*!
  \var SbPList * SoGtkRenderArea::deviceList
  FIXME: write doc
*/

// *************************************************************************

class SoGtkRenderAreaP {
public:

  SoGtkRenderAreaP(class SoGtkRenderArea * pub);
  ~SoGtkRenderAreaP(void);

  SbBool clear;
  SbBool clearZBuffer;
  SbBool clearOverlay;

  SoSceneManager * normalManager;
  SoSceneManager * overlayManager;

  SbColor * normalColormap;
  int normalColormapSize;
  int normalColormapStart;
  SbColor * overlayColormap;
  int overlayColormapSize;
  int overlayColormapStart;

  struct {
    SoGtkKeyboard * keyboard;
    SoGtkMouse * mouse;
  } devices;

  SbBool autoRedraw;

  SoSelection * normalSelection;
  SoSelection * overlaySelection;

  static const int GL_DEFAULT_MODE;

  // OpenGL info-window hack.
  enum { NONE, OPENGL, INVENTOR, TOOLKIT };
  int checkMagicSequences(const char c);
  void showOpenGLDriverInformation(void);
  void showInventorInformation(void);
  void showToolkitInformation(void);

private:
  SoGtkRenderArea * pub; // public interface class
  SbString currentinput; // For the OpenGL info-window hack.
}; // class SoGtkRenderAreaP

#define PRIVATE(ptr) (ptr->priv)
#define PUBLIC(ptr) (ptr->pub)

const int SoGtkRenderAreaP::GL_DEFAULT_MODE = (SO_GL_RGB |
                                                 SO_GL_ZBUFFER |
                                                 SO_GL_DOUBLE );

#if SOGTK_DEBUG && defined(__COIN__)
// Disabled when compiling against SGI / TGS Inventor, as we're using
// our Coin-specific extension SbString::sprintf() a lot.
#define DEBUGGING_EGGS 1
#endif // SOGTK_DEBUG && __COIN__

// Note: assumes a valid current OpenGL context.
void
SoGtkRenderAreaP::showOpenGLDriverInformation(void)
{
#if DEBUGGING_EGGS
  const GLubyte * vendor = glGetString(GL_VENDOR);
  const GLubyte * renderer = glGetString(GL_RENDERER);
  const GLubyte * version = glGetString(GL_VERSION);
  const GLubyte * extensions = glGetString(GL_EXTENSIONS);

  SbString info = "GL_VENDOR: \""; info += (const char *)vendor; info += "\"\n";
  info += "GL_RENDERER: \""; info += (const char *)renderer; info += "\"\n";
  info += "GL_VERSION: \""; info += (const char *)version; info += "\"\n";
  info += "GL_EXTENSIONS: \"\n   ";
    
  SbString exts = (const char *)extensions;
  const char * p;
  int count = 0;
  // (the extra parentheses in the while-expression kills a gcc warning)
  while ((p = strchr(exts.getString(), ' '))) {
    const char * start = exts.getString();
    info += exts.getSubString(0, p - start);
    exts.deleteSubString(0, p - start);
    count++;
    if (count == 4) { // number of extensions listed on each line
      info += "\n   ";
      count = 0;
    }
  }
  if (exts.getLength() > 0) { info += "\n   "; info += exts; }
  info += "\"\n";

  // Misc implementation info
  {
    SbVec2f range;
    float granularity;
    PUBLIC(this)->getPointSizeLimits(range, granularity);

    SbString s;
    s.sprintf("glPointSize(): range=[%f, %f], granularity=%f\n",
              range[0], range[1], granularity);
    info += s;


    PUBLIC(this)->getLineWidthLimits(range, granularity);

    s.sprintf("glLineWidth(): range=[%f, %f], granularity=%f\n",
              range[0], range[1], granularity);
    info += s;

    GLint depthbits[1];
    glGetIntegerv(GL_DEPTH_BITS, depthbits);
    s.sprintf("GL_DEPTH_BITS==%d\n", depthbits[0]);
    info += s;
  }

  SoGtk::createSimpleErrorDialog(NULL, "OpenGL driver information",
                                    info.getString());
#endif // DEBUGGING_EGGS
}

void
SoGtkRenderAreaP::showInventorInformation(void)
{
#if DEBUGGING_EGGS
  SbString info;
  info.sprintf("%s\n", SoDB::getVersion());

  // Display calculated maximum resolution of SbTime::getTimeOfDay().
  {
    const double DURATION = 0.2;  // in seconds
    SbTime current = SbTime::getTimeOfDay();
    SbTime end(current + DURATION);
    SbTime last = current;
    unsigned int ticks = 0;
    do {
      current = SbTime::getTimeOfDay();
      if (current.getValue() != last.getValue()) { ticks++; last = current; }
    } while (current < end);
    SbString s;
    s.sprintf("\nSbTime::getTimeOfDay() resolution: ~ %d Hz\n",
              (int)(((double)ticks) / DURATION));
    info += s;
  }

  // FIXME: dump list of available node classes? 20010927 mortene.
  SoGtk::createSimpleErrorDialog(NULL, "Inventor implementation info",
                                    info.getString());

#endif // DEBUGGING_EGGS
}

void
SoGtkRenderAreaP::showToolkitInformation(void)
{
#if DEBUGGING_EGGS
  SbString info = "SoGtk version "; info += SOGTK_VERSION; info += "\n";
#if SOGTK_MAKE_DLL
  info += "Built as MSWindows DLL.\n";
#endif // !SOGTK_MAKE_DLL

  // FIXME: include information about the underlying toolkit library,
  // if possible, like we do for Qt below (ie Gtk version, Motif
  // implementation, MSWindows version, ...).  20010927 mortene.

#ifdef SOQT_INTERNAL
  // Qt implementation info.
  {
    SbString s;
    s.sprintf("\nQt version: %s\nQGL version: %s\n", qVersion(), qGLVersion());
    info += s;
  }
#endif // SOQT_INTERNAL

  // FIXME: information about DLL path(s) (both for the SoGtk and
  // Coin/Inventor library) would be _extremely_ useful for debugging
  // "remote" applications, as application programmers (including
  // ourselves) tend to spread those files around misc diskdrive
  // directories -- especially on MSWindows platforms.  Mismatches for
  // run-time binding and link-time binding then causes bugs which are
  // impossible to make sense of.
  //
  // I don't know if any platforms have enough introspection
  // functionality to enable us to do this, though. Should
  // investigate. (update: GetModuleHandle() looks like the place to
  // start looking in the Win32 API.)
  //
  // 20010927 mortene.

  // FIXME: dump rcsid strings for all components. 20010927 mortene.

  // OpenGL canvas settings.
  {
    SbString s;
    s.sprintf("\nCurrent OpenGL canvas:\n"
              "         %sbuffer\n"
              "         drawing to %sbuffer\n"
              "         %s rendering%s\n"
              "         %s mode\n"
              "         with%s overlay planes\n",
              PUBLIC(this)->isDoubleBuffer() ? "double" : "single",
              PUBLIC(this)->isDrawToFrontBufferEnable() ? "front" : "back",
              PUBLIC(this)->isStereoBuffer() ? "stereo" : "mono",
              PUBLIC(this)->isQuadBufferStereo() ? " (OpenGL quadbuffer)" : "",
              PUBLIC(this)->isRGBMode() ? "RGB" : "colorindex",
              PUBLIC(this)->isOverlayRender() ? "" : "out");

    // FIXME: information about the native OpenGL widget format?
    // 20010927 mortene.

    info += s;
  }

  // Underlying Inventor implementation.
  {
    SbString s;
    s.sprintf("\nInventor implementation: %s\n", SoDB::getVersion());
    info += s;
  }

  SoGtk::createSimpleErrorDialog(NULL, "SoGtk implementation info",
                                    info.getString());
#endif // DEBUGGING_EGGS
}

int
SoGtkRenderAreaP::checkMagicSequences(const char c)
{
#if DEBUGGING_EGGS
  this->currentinput += c;

  if (0) { // handy for debugging keyboard handling
    SoDebugError::postInfo("SoGtkRenderAreaP::checkMagicSequences",
                           "'%s'", this->currentinput.getString());
  }

  int cl = this->currentinput.getLength();

  static const char glinfoseq[] = "glinfo";
  static const char ivinfoseq[] = "ivinfo";
  static const char soinfoseq[] = "soinfo";

  int ml = strlen(glinfoseq);
  if (cl >= ml && this->currentinput.getSubString(cl - ml) == glinfoseq) {
    return SoGtkRenderAreaP::OPENGL;
  }
  ml = strlen(ivinfoseq);
  if (cl >= ml && this->currentinput.getSubString(cl - ml) == ivinfoseq) {
    return SoGtkRenderAreaP::INVENTOR;
  }
  ml = strlen(soinfoseq);
  if (cl >= ml && this->currentinput.getSubString(cl - ml) == soinfoseq) {
    return SoGtkRenderAreaP::TOOLKIT;
  }

  // Limit memory usage.
  if (cl > 1024) { this->currentinput = ""; }
#endif // DEBUGGING_EGGS
  return SoGtkRenderAreaP::NONE;
}

// *************************************************************************

/*!
  \var SoGtkRenderAreaEventCB * SoGtkRenderArea::appEventHandler

  This is an application-settable event callback that will be called with
  X events destined for the renderarea.

  Set this member through the access methods, not directly.
*/

/*!
  \var void * SoGtkRenderArea::appEventHandlerData

  This member is the closure given to the application event handler.

  Set this member through the access methods, not directly.
*/

// *************************************************************************

// *************************************************************************

/*!
  Public constructor.
*/
SoGtkRenderArea::SoGtkRenderArea(GtkWidget * parent,
                                     const char * name,
                                     SbBool embed,
                                     SbBool mouseInput,
                                     SbBool keyboardInput)
  : inherited(parent, name, embed, SoGtkRenderAreaP::GL_DEFAULT_MODE, FALSE)
{
  this->constructor(mouseInput, keyboardInput, TRUE);
} // SoGtkRenderArea()

/*!
  Protected constructor used by derived classes.
*/
SoGtkRenderArea::SoGtkRenderArea(GtkWidget * parent,
                                     const char * name,
                                     SbBool embed,
                                     SbBool mouseInput,
                                     SbBool keyboardInput,
                                     SbBool build)
  : inherited(parent, name, embed, SoGtkRenderAreaP::GL_DEFAULT_MODE, FALSE)
{
  this->constructor(mouseInput, keyboardInput, build);
} // SoGtkRenderArea()

// Common code for all constructors.
void
SoGtkRenderArea::constructor(SbBool mouseInput,
                               SbBool keyboardInput,
                               SbBool build)
{
  PRIVATE(this) = new SoGtkRenderAreaP(this);

  PRIVATE(this)->normalManager->setRenderCallback(SoGtkRenderArea::renderCB, this);
  PRIVATE(this)->normalManager->activate();
  PRIVATE(this)->overlayManager->setRenderCallback(SoGtkRenderArea::renderCB, this);
  PRIVATE(this)->overlayManager->activate();
  // FIXME: what is this magic number doing here - shouldn't we use
  // SoGLCacheContextElement::getUniqueCacheContext() for Coin, and
  // magic numbers just for SGI / TGS Inventor?
  //
  // On a side note: won't this code fail if we construct several
  // SoGtkRenderArea instances with overlays? They will all use
  // cachecontext==1 for their SoGLRenderAction instances -- is that
  // kosher?
  //
  // 20010831 mortene.
  PRIVATE(this)->overlayManager->getGLRenderAction()->setCacheContext(1);

  this->deviceList = new SbPList ;
  this->appEventHandler = NULL;
  this->appEventHandlerData = NULL;

  if (mouseInput) {
    PRIVATE(this)->devices.mouse = new SoGtkMouse;

    // FIXME: somebody debug larsa's head so he learns to write proper
    // FIXME comments (see below), which _at least_ actually contains
    // a useful description of what doesn't work / is to be fixed. And
    // why not throw in the ability to tag the FIXME with a datestamp
    // and username aswell. Sheesh... 20010831 mortene.

    // FIXME: this does not work
    // this->registerDevice(PRIVATE(this)->devices.mouse);
    this->deviceList->append(PRIVATE(this)->devices.mouse);
  }

  if (keyboardInput) {
    PRIVATE(this)->devices.keyboard = new SoGtkKeyboard;
    // FIXME: this does not work
    // this->registerDevice(PRIVATE(this)->devices.keyboard);
    this->deviceList->append(PRIVATE(this)->devices.keyboard);
  }

  if (! build) return;
  this->setClassName("SoGtkRenderArea");
  GtkWidget * glarea = this->buildWidget(this->getParentWidget());
  this->setBaseWidget(glarea);
  this->setSize(SbVec2s(400, 400));
} // constructor()

/*!
  Destructor.
*/
SoGtkRenderArea::~SoGtkRenderArea()
{
  for (int i = this->deviceList->getLength() - 1; i >= 0; i--) {
    SoGtkDevice * device = (SoGtkDevice *) ((*this->deviceList)[i]);
    this->unregisterDevice(device);
    delete device;
  }
  delete this->deviceList;
  delete PRIVATE(this);
} // ~SoGtkRenderArea()

// *************************************************************************

/*!
  A hook invoked after window has been realized.
*/
void
SoGtkRenderArea::afterRealizeHook(void)
{
  inherited::afterRealizeHook();

#ifdef HAVE_JOYSTICK_LINUX
  if (SoGtkLinuxJoystick::exists())
    this->registerDevice(new SoGtkLinuxJoystick);
#endif // HAVE_JOYSTICK_LINUX

  if (SoGtkSpaceball::exists())
    this->registerDevice(new SoGtkSpaceball);
} // afterRealizeHook()

/*!
  This method sets the scene graph to be rendered in the normal bitmap
  planes.

  \sa getSceneGraph(), setOverlaySceneGraph()
*/
void
SoGtkRenderArea::setSceneGraph(SoNode * scene)
{
  PRIVATE(this)->normalManager->setSceneGraph(scene);
}

/*!
  This method returns a reference to the scene graph root node as set
  by the user.

  \sa SoGtkRenderArea::getSceneManager()
*/
SoNode *
SoGtkRenderArea::getSceneGraph(void)
{
  return PRIVATE(this)->normalManager->getSceneGraph();
}

/*!
  This method sets the scene graph to render for the overlay bitmap
  planes.

  It will automatically take care of setting up overplay planes in the
  OpenGL canvas if the OpenGL hardware and driver supports it.

  Important note: not all graphics hardware and / or drivers for
  graphics hardware support overlay planes, so application programmers
  are adviced to find some other way of accomplishing what they want
  to do before resorting to using overlay planes.  Using overlay
  planes will in practice severely limit the portability of
  applications which depend on them being available.

  \sa setSceneGraph(), getOverlaySceneGraph()
*/
void
SoGtkRenderArea::setOverlaySceneGraph(SoNode * scene)
{
  SoNode * oldroot = this->getOverlaySceneGraph();
  PRIVATE(this)->overlayManager->setSceneGraph(scene);

  if (!oldroot && scene) { this->setOverlayRender(TRUE); }
  else if (oldroot && !scene) { this->setOverlayRender(FALSE); }
}

/*!
  This method returns the scene graph for the overlay scene.
*/
SoNode *
SoGtkRenderArea::getOverlaySceneGraph(void)
{
  return PRIVATE(this)->overlayManager->getSceneGraph();
}

// *************************************************************************

/*!
  This method add \a device to the list of devices handling events for
  this component.
*/
void
SoGtkRenderArea::registerDevice(SoGtkDevice * device)
{
  int idx = deviceList->find(device);
  if (idx == -1)
    deviceList->append(device);

  device->setWindowSize(this->getGLSize());
  if (idx == -1)
    device->enable(this->getGLWidget(), 
      &SoGtkGLWidget::eventHandler, (void*) this);
} // registerDevice()

/*!
  This method removes \a device from the list of devices handling
  events for this component.
*/
void
SoGtkRenderArea::unregisterDevice(SoGtkDevice * device)
{
  assert(this->deviceList != NULL);
  const int idx = this->deviceList->find(device);
  if (idx == -1) {
#if SOGTK_DEBUG
    SoDebugError::post("SoGtkRenderArea::unregisterDevice",
                       "tried to remove nonexisting device");
#endif // SOGTK_DEBUG
    return;
  }
  this->deviceList->remove(idx);
  device->disable(this->getGLWidget(), NULL, NULL);
} // unregisterDevice()

// *************************************************************************

/*!
  This method sets the background color of the scene.
*/
void
SoGtkRenderArea::setBackgroundColor(const SbColor & color)
{
  assert(PRIVATE(this)->normalManager != NULL);
  PRIVATE(this)->normalManager->setBackgroundColor(color);
} // setBackgroundColor()

/*!
  This method returns the background color for the scene.
*/
const SbColor &
SoGtkRenderArea::getBackgroundColor(void) const
{
  assert(PRIVATE(this)->normalManager != NULL);
  return PRIVATE(this)->normalManager->getBackgroundColor();
} // getBackgroundColor()

// *************************************************************************

/*!
  This method sets the index of the background color for the scene.
*/
void
SoGtkRenderArea::setBackgroundIndex(int idx)
{
  assert(PRIVATE(this)->normalManager != NULL);
  PRIVATE(this)->normalManager->setBackgroundIndex(idx);
} // setBackgroundIndex()

/*!
  This method returns the index of the background color for the scene.
*/
int
SoGtkRenderArea::getBackgroundIndex(void) const
{
  assert(PRIVATE(this)->normalManager != NULL);
  return PRIVATE(this)->normalManager->getBackgroundIndex();
} // getBackgroundIndex()

// *************************************************************************

/*!
  This method sets the index of the background for the overlay scene.
*/
void
SoGtkRenderArea::setOverlayBackgroundIndex(int idx)
{
  assert(PRIVATE(this)->overlayManager != NULL);
  PRIVATE(this)->overlayManager->setBackgroundIndex(idx);
}

/*!
  This method returns the index of the background for the overlay scene.
*/
int
SoGtkRenderArea::getOverlayBackgroundIndex(void) const
{
  assert(PRIVATE(this)->overlayManager != NULL);
  return PRIVATE(this)->overlayManager->getBackgroundIndex();
}

// *************************************************************************

/*!
  This method sets the colormap for the scene.
*/
void
SoGtkRenderArea::setColorMap(int start, int num, const SbColor * colors)
{
  delete [] PRIVATE(this)->normalColormap;
  PRIVATE(this)->normalColormapStart = start;
  PRIVATE(this)->normalColormapSize = num;
  PRIVATE(this)->normalColormap = new SbColor [ num ];
  for (int i = 0; i < num; i++)
    PRIVATE(this)->normalColormap[i] = colors[i];
} // setColorMap()

/*!
  This method sets the colormap for the overlay scene.
*/
void
SoGtkRenderArea::setOverlayColorMap(int start, int num,
                                      const SbColor * colors)
{
  delete [] PRIVATE(this)->overlayColormap;
  PRIVATE(this)->overlayColormapStart = start;
  PRIVATE(this)->overlayColormapSize = num;
  PRIVATE(this)->overlayColormap = new SbColor [ num ];
  for (int i = 0; i < num; i++) {
    PRIVATE(this)->overlayColormap[i] = colors[i];
  }
}

// *************************************************************************

/*!
  This method sets the viewport region.
*/
void
SoGtkRenderArea::setViewportRegion(const SbViewportRegion & region)
{
  if (region.getWindowSize()[0] == -1) return;

#if SOGTK_DEBUG && 0 // debug
  SoDebugError::postInfo("SoGtkRenderArea::setViewportRegion",
                         "size=<%d, %d>",
                         region.getWindowSize()[0],
                         region.getWindowSize()[1]);
#endif // debug

  PRIVATE(this)->normalManager->setViewportRegion(region);
  PRIVATE(this)->overlayManager->setViewportRegion(region);
}

/*!
  This method returns the viewport region.
*/
const SbViewportRegion &
SoGtkRenderArea::getViewportRegion(void) const
{
  assert(PRIVATE(this)->normalManager != NULL);
  return PRIVATE(this)->normalManager->getGLRenderAction()->getViewportRegion();
} // getViewportRegion()

// *************************************************************************

/*!
  This method sets the transparency type to be used for the scene.
*/
void
SoGtkRenderArea::setTransparencyType(SoGLRenderAction::TransparencyType type)
{
  assert(PRIVATE(this)->normalManager != NULL);
  PRIVATE(this)->normalManager->getGLRenderAction()->setTransparencyType(type);
  PRIVATE(this)->overlayManager->getGLRenderAction()->setTransparencyType(type);
} // setTransparencyType()

/*!
  This method returns the transparency type used for the scene.
*/
SoGLRenderAction::TransparencyType
SoGtkRenderArea::getTransparencyType(void) const
{
  assert(PRIVATE(this)->normalManager != NULL);
  return PRIVATE(this)->normalManager->getGLRenderAction()->getTransparencyType();
} // getTransparencyType()

// *************************************************************************

/*!
  This method sets the antialiasing used for the scene.
*/
void
SoGtkRenderArea::setAntialiasing(SbBool smoothing, int numPasses)
{
  // FIXME: is this really necessary? I think we should either ignore
  // the call or store values for later migration if the scenemanager
  // instance(s) haven't been made yet. 20010331 mortene.
  assert(PRIVATE(this)->normalManager != NULL);

  // Instead of piping the call further to
  // SoSceneManager::setAntialiasing(), we duplicate the code found in
  // that function. The reason for this is that we want to work around
  // a bug found in SGI Inventor, where they define the
  // setAntialiasing() method, but doesn't actually implement it.  So
  // we don't use it to avoid a linker error for those compiling So*
  // libraries on top of the older SGI Inventor versions with this
  // bug.
  //
  // We should perhaps throw in a configure check for the
  // SoSceneManager::setAntialiasing() method and only activate this
  // code when actually needed?
  //                                                   mortene@sim.no
  enum { MGRS = 2 };
  SoSceneManager * mgrs[MGRS] = { PRIVATE(this)->normalManager,
                                  PRIVATE(this)->overlayManager };
  for (int i=0; i < MGRS; i++) {
    SoGLRenderAction * glra = mgrs[i]->getGLRenderAction();
    if (glra) {
      glra->setSmoothing(smoothing);
      glra->setNumPasses(numPasses);
    }
  }
} // setAntialiasing()

/*!
  This method returns the antialiasing used for the scene.
*/
void
SoGtkRenderArea::getAntialiasing(SbBool & smoothing, int & numPasses) const
{
  // FIXME: there's an API design flaw here, as it is assumed that the
  // antialiasing setting for the renderaction in the "normal"
  // rendering context always matches what is the case for the
  // renderaction in the overlay manager. This is not necessarily
  // true. Could be solved by an additional argument to
  // getAntialiasing(): a boolean indicator on whether or not we want
  // the overlay context with a default value (false) to keep API
  // compatibility. 20010331 mortene.

  assert(PRIVATE(this)->normalManager != NULL);

  // About why we don't use SoSceneManager::getAntialiasing()
  // directly, see comment in SoGuiRenderArea::setAntiAliasing().
  SoGLRenderAction * glra = PRIVATE(this)->normalManager->getGLRenderAction();
  smoothing = glra->isSmoothing();
  numPasses = glra->getNumPasses();
} // getAntialiasing()

/*!
  This method sets whether the render buffer should be cleared before
  rendering.
*/
void
SoGtkRenderArea::setClearBeforeRender(SbBool enable, SbBool zbEnable)
{
  PRIVATE(this)->clear = enable;
  PRIVATE(this)->clearZBuffer = zbEnable;
} // setClearBeforeRender()

/*!
  This method returns whether the render buffer is cleared before each
  render.
*/
SbBool
SoGtkRenderArea::isClearBeforeRender(void) const
{
  return PRIVATE(this)->clear;
} // isClearBeforeRender()

/*!
  This method returns whether the render buffer's Z buffer is cleared
  before each render.
*/
SbBool
SoGtkRenderArea::isClearZBufferBeforeRender(void) const
{
  return PRIVATE(this)->clearZBuffer;
} // isClearZBufferBeforeRender()

/*!
  This method sets whether the overlay render buffer should be cleared
  before each render or not.
*/
void
SoGtkRenderArea::setClearBeforeOverlayRender(SbBool enable)
{
  PRIVATE(this)->clearOverlay = enable;
}

/*!
  This method returns whether the overlay render buffer is cleared
  before each redraw or not.
*/
SbBool
SoGtkRenderArea::isClearBeforeOverlayRender(void) const
{
  return PRIVATE(this)->clearOverlay;
}

/*!
  This method sets whether redrawing should be handled automatically
  or not when data in the scenegraph changes.

  The default setting causes the renderarea to automatically trigger a
  redraw of the scenegraph contents.
*/
void
SoGtkRenderArea::setAutoRedraw(SbBool enable)
{
  if (enable) {
    PRIVATE(this)->normalManager->setRenderCallback(SoGtkRenderArea::renderCB, this);
    PRIVATE(this)->overlayManager->setRenderCallback(SoGtkRenderArea::renderCB, this);
  }
  else {
    PRIVATE(this)->normalManager->setRenderCallback(NULL, NULL);
    PRIVATE(this)->overlayManager->setRenderCallback(NULL, NULL);
  }

  // We can not use the render callback ptr as a flag, as the render
  // callback pointer will be set upon expose events and forced
  // redraws -- and autoRedraw is then used to remember that the
  // pointer should be set back to NULL again after redraw.
  PRIVATE(this)->autoRedraw = enable;
}

/*!
  This method returns whether redrawing is handled automatically 
  not.
*/
SbBool
SoGtkRenderArea::isAutoRedraw(void) const
{
  return PRIVATE(this)->autoRedraw;
}

/*!
  This method sets the redraw priority.
*/
void
SoGtkRenderArea::setRedrawPriority(uint32_t priority)
{
  PRIVATE(this)->normalManager->setRedrawPriority(priority);
  PRIVATE(this)->overlayManager->setRedrawPriority(priority);
}

/*!
  This method returns the redraw priority.
*/
uint32_t
SoGtkRenderArea::getRedrawPriority(void) const
{
  assert(PRIVATE(this)->normalManager != NULL);
  return PRIVATE(this)->normalManager->getRedrawPriority();
} // getRedrawPriority()

/*!
  This function returns the default redraw priority.
*/
uint32_t
SoGtkRenderArea::getDefaultRedrawPriority(void) // static
{
  return SoSceneManager::getDefaultRedrawPriority();
} // getDefaultRedrawPriority()

/*!
  This method renders the scene.
*/
void
SoGtkRenderArea::render(void)
{
  this->redraw();
} // render()

/*!
  This method renders the overlay scene.
*/
void
SoGtkRenderArea::renderOverlay(void)
{
  this->redrawOverlay();
}

/*!
  This method schedules a redraw to happen at a later time (when the
  application has processed it's other events first).
*/
void
SoGtkRenderArea::scheduleRedraw(void)
{
#if SOGTK_DEBUG && RENDERAREA_DEBUG_REDRAWS // debug
  SoDebugError::postInfo("SoGtkRenderArea::scheduleRedraw",
                         "invoked");
#endif // debug

  assert(PRIVATE(this)->normalManager != NULL);
  // In case autoRedraw is OFF. The callback pointer will be reset to
  // NULL in renderCB() if autoRedraw is OFF.
  PRIVATE(this)->normalManager->setRenderCallback(SoGtkRenderArea::renderCB, this);
  PRIVATE(this)->normalManager->scheduleRedraw(); // Redraw when idle.
} // scheduleRedraw()

/*!
  This method schedules a redraw of the overlay scene.
*/
void
SoGtkRenderArea::scheduleOverlayRedraw(void)
{
  assert(PRIVATE(this)->overlayManager != NULL);
  // In case autoRedraw is OFF. The callback pointer will be reset to
  // NULL in renderCB() if autoRedraw is OFF.
  PRIVATE(this)->overlayManager->setRenderCallback(SoGtkRenderArea::renderCB, this);
  PRIVATE(this)->overlayManager->scheduleRedraw(); // Redraw when idle.
}

/*!
  Do automatic redraw of the scenegraph when a selection under the
  SoSelection node is changed.

  Pass \c NULL to deactivate.

  (Only one SoSelection node can be monitored at any given time. This
  is obviously a rather silly design flaw. We choose to match the
  original Inventor API here, but this will probably change in the
  next major revision of the library.)
*/
void
SoGtkRenderArea::redrawOnSelectionChange(SoSelection * selection)
{
  // FIXME: this interface is badly designed, see the comment above in
  // the function documentation. 20001002 mortene.

  if (PRIVATE(this)->normalSelection) {
    // FIXME: should we ref() and unref() to make sure we can't get a
    // crash here? 20001002 mortene.
    PRIVATE(this)->normalSelection->removeChangeCallback(SoGtkRenderArea::selection_redraw_cb, this);
  }

  PRIVATE(this)->normalSelection = selection;

  if (selection)
    selection->addChangeCallback(SoGtkRenderArea::selection_redraw_cb, this);

} // redrawOnSelectionChange()

/*!
  Do automatic redraw of the scenegraph in the overlay planes when a
  selection under the SoSelection node is changed.

  Pass \c NULL to deactivate.

  \sa SoGtkRenderArea::redrawOnSelectionChange()
*/
void
SoGtkRenderArea::redrawOverlayOnSelectionChange(SoSelection * selection)
{
  // FIXME: this interface is badly designed, see the comment above in
  // the function documentation on redrawOnSelectionChange(). 20001002 mortene.

  if (PRIVATE(this)->overlaySelection) {
    // FIXME: should we ref() and unref() to make sure we can't get a
    // crash here? 20001002 mortene.
    PRIVATE(this)->overlaySelection->removeChangeCallback(SoGtkRenderArea::selection_redraw_cb, this);
  }

  PRIVATE(this)->overlaySelection = selection;

  if (selection)
    selection->addChangeCallback(SoGtkRenderArea::selection_redraw_cb, this);

} // redrawOverlayOnSelectionChange()

/*!
  This method sets the render area event callback.
*/
void
SoGtkRenderArea::setEventCallback(SoGtkRenderAreaEventCB * func,
                                    void * user)
{
  this->appEventHandler = func;
  this->appEventHandlerData = user;
} // setEventCallback()

/*!
  This method sets the normal scene SoSceneManager object.
*/
void
SoGtkRenderArea::setSceneManager(SoSceneManager * manager)
{
  assert(PRIVATE(this)->normalManager != NULL);
  PRIVATE(this)->normalManager = manager;
} // setSceneManager()

/*!
  This method returns the normal scene SoSceneManager object.

  Having a reference to the SoSceneManager instance is useful for
  getting at the \e real root node of the rendering scenegraph,
  including camera, headlight and miscellaneous drawstyle nodes.  The
  getSceneGraph() method will only return the \e user scenegrah for
  SoGtkRenderArea subclass SoGtkViewer and further subclasses. The
  reason this is not always what you want is because certain actions
  (like the SoRayPickAction) needs to traverse a valid camera if it
  should work as expected.

  If you need to get a pointer to the \e real root node use this
  method to get the SoSceneManager instance reference used by the
  SoGtkRenderArea, then use SoSceneManager::getSceneGraph() to get
  the root node Coin uses for rendering.
*/
SoSceneManager *
SoGtkRenderArea::getSceneManager(void) const
{
  return PRIVATE(this)->normalManager;
} // getSceneManager()

/*!
  This method sets the overlay scene SoSceneManager object.
*/
void
SoGtkRenderArea::setOverlaySceneManager(SoSceneManager * manager)
{
  PRIVATE(this)->overlayManager = manager;
}

/*!
  This method returns the overlay scene SoSceneManager object.
*/
SoSceneManager *
SoGtkRenderArea::getOverlaySceneManager(void) const
{
  return PRIVATE(this)->overlayManager;
}

/*!
  This method sets the SoGLRenderAction object for the normal scene.
*/
void
SoGtkRenderArea::setGLRenderAction(SoGLRenderAction * action)
{
  assert(PRIVATE(this)->normalManager != NULL);
  PRIVATE(this)->normalManager->setGLRenderAction(action);
  // Force an update of the SoGLRenderAction to the correct
  // updatearea, aspectratio, etc.
  this->sizeChanged(this->getSize());
}

/*!
  This method returns the SoGLRenderAction object for the normal scene.
*/
SoGLRenderAction *
SoGtkRenderArea::getGLRenderAction(void) const
{
  assert(PRIVATE(this)->normalManager != NULL);
  return PRIVATE(this)->normalManager->getGLRenderAction();
} // getGLRenderAction()

/*!
  This method sets the SoGLRenderAction object for rendering the
  overlay scenegraph.
*/
void
SoGtkRenderArea::setOverlayGLRenderAction(SoGLRenderAction * action)
{
  assert(PRIVATE(this)->overlayManager != NULL);
  PRIVATE(this)->overlayManager->setGLRenderAction(action);
}

/*!
  This method returns the SoGLRenderAction object for the overlay scene
  graph.
*/
SoGLRenderAction *
SoGtkRenderArea::getOverlayGLRenderAction(void) const
{
  assert(PRIVATE(this)->overlayManager != NULL);
  return PRIVATE(this)->overlayManager->getGLRenderAction();
}

/*!
  This method redraws the normal scene graph.
*/
void
SoGtkRenderArea::redraw(void) // virtual, protected
{
#if SOGTK_DEBUG && RENDERAREA_DEBUG_REDRAWS // debug
  SoDebugError::postInfo("SoGtkRenderArea::render",
                         "start (isVisible=%s waitForExpose=%s)",
                         this->isVisible() ? "TRUE" : "FALSE",
                         this->waitForExpose ? "TRUE" : "FALSE");
#endif // debug

  if (! this->isVisible() || !this->hasNormalGLArea() || this->waitForExpose)
    return;
  this->glLockNormal(); // this makes the GL context "current"

  SbBool drawfront =
    ! this->isDoubleBuffer() ||
    this->isDrawToFrontBufferEnable();

  glDrawBuffer(drawfront ? GL_FRONT : GL_BACK);

  this->actualRedraw();

  if (!drawfront) { this->glSwapBuffers(); }
  else { this->glFlushBuffer(); }
  this->glUnlockNormal();

#if SOGTK_DEBUG && RENDERAREA_DEBUG_REDRAWS // debug
  SoDebugError::postInfo("SoGtkRenderArea::render", "done");
#endif // debug
} // redraw()

/*!
  This method redraws the normal scene graph.
*/
void
SoGtkRenderArea::actualRedraw(void) // virtual, protected
{
  assert(PRIVATE(this)->normalManager != NULL);
  if (! this->isVisible()) return;
  PRIVATE(this)->normalManager->render(PRIVATE(this)->clear, PRIVATE(this)->clearZBuffer);
} // actualRedraw()

/*!
  This method redraws the overlay scene.
*/
void
SoGtkRenderArea::redrawOverlay(void) // virtual, protected
{
  if (!this->isVisible() || this->waitForExpose || !this->hasOverlayGLArea()) {
    return;
  }
  
  this->glLockOverlay();
  this->actualOverlayRedraw();
  this->glFlushBuffer();
  this->glUnlockOverlay();
} // redrawOverlay()

/*!
  This method renders the overlay scene.
*/
void
SoGtkRenderArea::actualOverlayRedraw(void)
{
  assert(PRIVATE(this)->overlayManager != NULL);
  if (! this->isVisible()) return;
  PRIVATE(this)->overlayManager->render(PRIVATE(this)->clearOverlay,
                                        PRIVATE(this)->clearZBuffer);
}

/*!
  This method is invoked to initialize the normal graphics.
*/
void
SoGtkRenderArea::initGraphic(void) // virtual, protected
{
  SoSceneManager * mgr = this->getSceneManager();
  if (mgr) {
    mgr->reinitialize();
    mgr->setRGBMode(this->isRGBMode());
    mgr->getGLRenderAction()->setCacheContext(SoAny::si()->getSharedCacheContextId((void*) this));  
  }
  // FIXME: should init cache context stuff,
  // FIXME: if not RGB mode, load colormap

  inherited::initGraphic();
}

/*!
  This method is invoked to initialize the overlay graphics.
*/
void
SoGtkRenderArea::initOverlayGraphic(void) // virtual, protected
{
  SoSceneManager * mgr = this->getOverlaySceneManager();
  if (mgr) {
    mgr->reinitialize();
    mgr->setRGBMode(FALSE);
  }
  // FIXME: load colormap

  // FIXME: shouldn't we do inherited::initOverlayGraphic() ? 20010831 mortene.
}

// doc in super
void
SoGtkRenderArea::sizeChanged(const SbVec2s & size)
{
#if SOGTK_DEBUG && 0
  SoDebugError::postInfo("SoGtkRenderArea::sizeChanged",
                          "invoked, <%d, %d>", size[0], size[1]);
#endif // SOGTK_DEBUG

  if (size[0] == -1)
    return;

  assert(PRIVATE(this)->normalManager != NULL);
  assert(PRIVATE(this)->overlayManager != NULL);

  this->setGLSize(size);
  const SbVec2s glsize = this->getGLSize();

#if SOGTK_DEBUG && 0
  SoDebugError::postInfo("SoGtkRenderArea::sizeChanged",
                          "glsize==<%d, %d>", glsize[0], glsize[1]);
#endif // SOGTK_DEBUG

  if (glsize[0] <= 0 || glsize[1] <= 0)
    return;

  this->setViewportRegion(SbViewportRegion(glsize));
  this->setDevicesWindowSize(glsize);

  // FIXME: aren't both these calls unnecessary as we set the full
  // viewportregion a few lines above this one? 20020103 mortene.
  PRIVATE(this)->normalManager->setWindowSize(glsize);
  PRIVATE(this)->normalManager->setSize(glsize);

  // FIXME: aren't both these calls unnecessary as we set the full
  // viewportregion a few lines above this one? 20020103 mortene.
  PRIVATE(this)->overlayManager->setWindowSize(glsize);
  PRIVATE(this)->overlayManager->setSize(glsize);

  this->scheduleRedraw();
} // sizeChanged()

// Documented in superclass.
void
SoGtkRenderArea::widgetChanged(GtkWidget * widget) // virtual, protected
{
  PRIVATE(this)->normalManager->reinitialize();
  PRIVATE(this)->overlayManager->reinitialize();
  // FIXME: colorindex mode not supported yet, so this has no
  // effect. 20001121 mortene.
#if 0
  PRIVATE(this)->normalManager->setRGBMode(this->isRGBMode());
  PRIVATE(this)->overlayManager->setRGBMode(this->isRGBMode());
#endif

  // FIXME: this code needs to be enabled (and rewritten to work) to
  // handle display list caching. 20001121 mortene.
  // UPDATE: check with pederb if any of this is really needed, or if
  // it should just be removed. 20010802 mortene.
#if 0
  SoGLRenderAction * ra = PRIVATE(this)->normalManager->getGLRenderAction();
  ra->setCacheContext(XXX);
  ra->setRenderingIsRemote(XXX);
  ra = PRIVATE(this)->overlayManager->getGLRenderAction();
  ra->setCacheContext(XXX);
  ra->setRenderingIsRemote(XXX);
#endif

  // FIXME: should also walk through all registered devices and do a
  // disable() on the old widget and enable() on the new one.
  // 20001121 mortene.

} // widgetChanged()

/*!
  This method builds the SoGtkRenderArea contents in the \a parent
  widget.
*/
GtkWidget *
SoGtkRenderArea::buildWidget(GtkWidget * parent) // protected
{
  GtkWidget * widget = inherited::buildWidget(parent);
  if (this->deviceList != NULL) {
    const int num = this->deviceList->getLength();
    for (int i = 0; i < num; i++) {
      SoGtkDevice * device = (SoGtkDevice *) (*this->deviceList)[i];
      device->enable(this->getGLWidget(),
        &inherited::eventHandler, (void *) this);
    }
  }
  const SbVec2s glsize = this->getGLSize();
  if (glsize[0] <= 0 || glsize[1] <= 0)
    return widget;

/*
  this->setDevicesWindowSize(glsize);

  this->setViewportRegion(SbViewportRegion(glsize[0], glsize[1]));
  PRIVATE(this)->normalManager->setViewportRegion(SbViewportRegion(glsize[0], glsize[1]));
  PRIVATE(this)->overlayManager->setViewportRegion(SbViewportRegion(glsize[0], glsize[1]));
*/
  return widget;
} // buildWidget()

/*!
  This method returns a default widget name for the base widget.
*/
const char *
SoGtkRenderArea::getDefaultWidgetName(void) const // virtual, protected
{
  static const char defaultWidgetName[] = "SoGtkWidgetName";
  return defaultWidgetName;
} // getDefaultTitle()

/*!
  This method returns a default title for the component window.
*/
const char *
SoGtkRenderArea::getDefaultTitle(void) const // virtual, protected
{
  static const char defaultTitle[] = "Gtk RenderArea";
  return defaultTitle;
} // getDefaultTitle()

/*!
  This method returns a default title for the component window icon.
*/
const char *
SoGtkRenderArea::getDefaultIconTitle(void) const // virtual, protected
{
  static const char defaultIconTitle[] = "Gtk RenderArea";
  return defaultIconTitle;
} // getDefaultIconTitle()

/*!
  This method invokes the application event handler, if one is set.
*/
SbBool
SoGtkRenderArea::invokeAppCB(GdkEvent * event) // protected
{
  if (this->appEventHandler != NULL)
    return this->appEventHandler(this->appEventHandlerData, event);
  return FALSE;
} // invokeAppCB()

// *************************************************************************

/*!
  Toolkit-native events are attempted converted to Coin-generic events
  in the SoGtkRenderArea::processEvent() method.  If this succeeds,
  they are forwarded to this method.

  This is a virtual method, and is overridden in it's subclasses to
  catch events of particular interest to the viewer classes, for
  instance.

  Returns \c TRUE iff the event was processed, if not it should be
  passed on further up in the inheritance hierarchy by the caller.
  This last point is extremely important to take note of if you are
  expanding the toolkit with your own viewer class.

  This method is not part of the original SGI InventorXt API.
*/
SbBool
SoGtkRenderArea::processSoEvent(const SoEvent * const event)
{
  if (PRIVATE(this)->overlayManager->processEvent(event)) { return TRUE; }
  if (PRIVATE(this)->normalManager->processEvent(event)) { return TRUE; }
  return FALSE;
}

// *************************************************************************

/*!
  Overrides SoGtkGLWidget::processEvent() to attempt to convert
  toolkit-native events to Coin-generic events.  If this succeeds, the
  generic SoEvent is forwarded to SoGtkRenderArea::processSoEvent().
 */
void
SoGtkRenderArea::processEvent(GdkEvent * event)
{
  if (this->invokeAppCB(event)) { return; }

  const SoEvent * soevent = this->getSoEvent(event);

  if (soevent != NULL) {
#if SOGTK_DEBUG
    // Undocumented feature: there are several "magic" sequences of
    // keys when tapped into the rendering canvas which'll pop up a
    // dialog box with information about that particular feature.
    //
    // See code comments behind "case" statements below for which
    // sequences are available so far.

    if (soevent->isOfType(SoKeyboardEvent::getClassTypeId())) {
      SoKeyboardEvent * ke = (SoKeyboardEvent *)soevent;
      if (ke->getState() == SoButtonEvent::UP) {
        char c = ke->getPrintableCharacter();
        switch (PRIVATE(this)->checkMagicSequences(c)) {
        case SoGtkRenderAreaP::NONE:
          break;
        case SoGtkRenderAreaP::OPENGL:  // "glinfo"
          this->glLockNormal();
          PRIVATE(this)->showOpenGLDriverInformation();
          this->glUnlockNormal();
          break;
        case SoGtkRenderAreaP::INVENTOR:  // "ivinfo"
          PRIVATE(this)->showInventorInformation();
          break;
        case SoGtkRenderAreaP::TOOLKIT:  // "soinfo"
          PRIVATE(this)->showToolkitInformation();
          break;
        default:
          assert(FALSE && "unknown debug key sequence");
          break;
        }
      }
    }
#endif // SOGTK_DEBUG

    SbBool processed = this->processSoEvent(soevent);
    if (processed) return;
  }

  inherited::processEvent(event);
}

// *************************************************************************

// doc from parent
SbBool 
SoGtkRenderArea::glScheduleRedraw(void)
{
  this->scheduleRedraw();
  if (this->hasOverlayGLArea() && this->getOverlaySceneGraph()) {
    this->scheduleOverlayRedraw();
  }
  return TRUE;
}


/*!
  This method returns an SoEvent * corresponding to the given \a
  event, or \c NULL if there are none.
*/
const SoEvent *
SoGtkRenderArea::getSoEvent(GdkEvent * event)
{
  if (! this->deviceList)
    return (SoEvent *) NULL;

  const SoEvent * soevent = NULL;
  const int num = this->deviceList->getLength();
  for (int i = 0; (i < num) && (soevent == NULL); i++)
    soevent = ((SoGtkDevice *)(*this->deviceList)[i])->translateEvent(event);

  return soevent;
} // getSoEvent()

// *************************************************************************

/*!
  This method sets the window size data in all the connected device
  classes.
*/
void
SoGtkRenderArea::setDevicesWindowSize(const SbVec2s size)
{
  if (! this->deviceList) return;
  const int num = this->deviceList->getLength();
  for (int i = 0; i < num; i++)
    ((SoGtkDevice *)(*this->deviceList)[i])->setWindowSize(size);
} // setDevicesWindowSize()

// *************************************************************************

void
SoGtkRenderArea::renderCB(void * closure, SoSceneManager * manager)
{
  SoGtkRenderArea * thisptr = (SoGtkRenderArea *) closure;
  if (manager == PRIVATE(thisptr)->normalManager)
    thisptr->render();
  else if (manager == PRIVATE(thisptr)->overlayManager)
    thisptr->renderOverlay();
  else assert(0);

  if (!thisptr->isAutoRedraw())
    manager->setRenderCallback(NULL, NULL);
} // renderCB()

/*!
  Callback for automatic redraw on SoSelection changes.
*/
void
SoGtkRenderArea::selection_redraw_cb(void * closure, SoSelection * sel)
{
  SoGtkRenderArea * ra = (SoGtkRenderArea *) closure;
  if (sel == PRIVATE(ra)->normalSelection)
    ra->scheduleRedraw();
  else if (sel == PRIVATE(ra)->overlaySelection)
    ra->scheduleOverlayRedraw();
  else
    assert(0 && "callback on unknown SoSelection node");
} // selection_redraw_cb

// *************************************************************************

/*!
  Private class constructor.
*/
SoGtkRenderAreaP::SoGtkRenderAreaP(SoGtkRenderArea * pub)
{
  PUBLIC(this) = pub;

  this->normalManager = new SoSceneManager;
  this->overlayManager = new SoSceneManager;

  this->normalColormap = NULL;
  this->normalColormapSize = 0;
  this->overlayColormap = NULL;
  this->overlayColormapSize = 0;

  this->clear = TRUE;
  this->clearZBuffer = TRUE;
  this->clearOverlay = TRUE;
  this->autoRedraw = TRUE;

  this->normalSelection = NULL;
  this->overlaySelection = NULL;

  this->devices.mouse = NULL;
  this->devices.keyboard = NULL;
} // SoGtkRenderAreaP()

/*!
  Private class destructor.
*/
SoGtkRenderAreaP::~SoGtkRenderAreaP()
{
  delete this->normalManager;
  delete this->overlayManager;
  delete [] this->normalColormap;
  delete [] this->overlayColormap;
} // ~SoGtkRenderAreaP()

// *************************************************************************

/*!
  This method posts and processes an SoEvent object to the
  SoGtkRenderArea-based component and returns the result value from the
  event handler.  This is a synchronous operation.
*/
SbBool
SoGtkRenderArea::sendSoEvent(const SoEvent * event)
{
  return this->processSoEvent(event);
} // handleSoEvent()

// *************************************************************************

#if SOGTK_DEBUG
static const char * getSoGtkRenderAreaRCSId(void) { return rcsid; }
#endif // SOGTK_DEBUG
