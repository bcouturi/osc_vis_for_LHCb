/**************************************************************************
 *
 *  This file is part of the Coin GUI binding libraries.
 *  Copyright (C) 2000-2001 by Systems in Motion.  All rights reserved.
 *
 *  The libraries this file is part of is free software; you can
 *  redistribute them and/or modify them under the terms of the GNU
 *  Lesser General Public License version 2.1 as published by the
 *  Free Software Foundation.  See the file LICENSE.LGPL at the root
 *  directory of the distribution for all the details.
 *
 *  If you want to use the Coin GUI binding libraries for applications
 *  not compatible with the LGPL, contact SIM about acquiring a
 *  Professional Edition License.
 *
 *  Systems in Motion, Prof Brochs gate 6, N-7030 Trondheim, NORWAY
 *  http://www.sim.no/ support@sim.no Voice: +47 22114160 Fax: +47 22207097
 *
 **************************************************************************/

// @configure_input@

#if SOGTK_DEBUG
static const char rcsid[] =
  "";
#endif // SOGTK_DEBUG

// *************************************************************************

/*!
  \class SoGtkViewer Inventor/Gtk/viewers/SoGtkViewer.h
  \brief The SoGtkViewer class is the top level base viewer class.
  \ingroup components viewers common

  FIXME: document properly
  ...overview of what this class provides over parent class...
  ...keyboard combinations: Home, s, arrow keys (but only during
  viewing), Esc...
  ...explain pan, rotate, zoom, dolly, seek...
  ..explain the fact that we're moving the camera, not the scene...
  ...viewer modes (examine vs interact) w/ explanation of what they are
  useful for...
*/

// NOTE: The SoGtkViewer.cpp sourcecode file is completely
// autogenerated from "templatized" source code.

// *************************************************************************

#if HAVE_CONFIG_H
#include <config.h>
#endif // HAVE_CONFIG_H

#ifdef SOQT_INTERNAL
#include <qmetaobject.h>
#include <moc_SoQtViewer.cpp>
#endif // SOQT_INTERNAL

#include <stdlib.h>
#include <string.h>
#include <math.h>

#include <Inventor/Gtk/common/gl.h>
#include <Inventor/Gtk/SoAny.h>

#include <Inventor/SoDB.h>

#include <Inventor/nodes/SoBaseColor.h>
#include <Inventor/nodes/SoComplexity.h>
#include <Inventor/nodes/SoDirectionalLight.h>
#include <Inventor/nodes/SoDrawStyle.h>
#include <Inventor/nodes/SoLightModel.h>
#include <Inventor/nodes/SoLocateHighlight.h>
#include <Inventor/nodes/SoMaterialBinding.h>
#include <Inventor/nodes/SoOrthographicCamera.h>
#include <Inventor/nodes/SoPerspectiveCamera.h>
#include <Inventor/nodes/SoSeparator.h>
#include <Inventor/nodes/SoSwitch.h>
#include <Inventor/nodekits/SoBaseKit.h>

#include <Inventor/actions/SoGetBoundingBoxAction.h>
#include <Inventor/actions/SoGetMatrixAction.h>
#include <Inventor/actions/SoSearchAction.h>
#include <Inventor/actions/SoRayPickAction.h>

#include <Inventor/events/SoMouseButtonEvent.h>
#include <Inventor/errors/SoDebugError.h>
#include <Inventor/misc/SoCallbackList.h>
#include <Inventor/sensors/SoTimerSensor.h>
#include <Inventor/events/SoKeyboardEvent.h>
#include <Inventor/SoSceneManager.h>
#include <Inventor/SoPickedPoint.h>
#include <Inventor/SoLists.h>
#include <Inventor/SbLinear.h>

#include <sogtkdefs.h>
#include <Inventor/Gtk/SoGtk.h>
#include <Inventor/Gtk/viewers/SoGtkViewer.h>
#include <math.h>
#include <float.h> // FLT_MAX

#if HAVE_SOPOLYGONOFFSET
#include <Inventor/nodes/SoPolygonOffset.h>
#endif // HAVE_SOPOLYGONOFFSET

#ifndef M_PI
#define M_PI 3.1415926535f
#endif // ! M_PI

// (note: this *must* be a #define, not a static variable -- to avoid
// initialization race conditions with the static variables being set
// to the value of this)
#define UNINITIALIZED_ENVVAR -1 // value of envvars before tested

// environment variables
static int COIN_SHOW_FPS_COUNTER = UNINITIALIZED_ENVVAR;

// *************************************************************************

// The private data for the SoGtkViewer.
class SoGtkViewerP {
public:
  SoGtkViewerP(SoGtkViewer * publ);
  ~SoGtkViewerP(void);

  SoSeparator * createSuperScene(void);
  SoSeparator * createFPSSuperimposition(void);

  // Seek functionality
  SoTimerSensor * seeksensor;
  float seekperiod;
  SbBool inseekmode;
  SbBool seektopoint;
  SbVec3f camerastartposition, cameraendposition;
  SbRotation camerastartorient, cameraendorient;
  float seekdistance;
  SbBool seekdistanceabs;

  // Camera handling
  SbBool deletecamera;
  SbVec3f storedposition;
  SbRotation storedorientation;
  float storedheightval;

  SoDirectionalLight * headlight;

  // Drawstyles
  SoGtkViewer::DrawStyle drawstyles[2];
  SoSwitch * drawstyleroot, * hiddenlineroot, * polygonoffsetparent;
  SoBaseColor * sobasecolor;
  SoComplexity * socomplexity;
  SoDrawStyle * sodrawstyle;
  SoLightModel * solightmodel;
  SoMaterialBinding * somaterialbinding;
  SoSeparator * usersceneroot;
  SoSwitch * superimpositionroot;
#if HAVE_SOPOLYGONOFFSET
  SoPolygonOffset * sopolygonoffset;
#endif // HAVE_SOPOLYGONOFFSET
  // Automatic setting of clipping planes
  SbBool adjustclipplanes;

  SoSeparator * fpsRoot;

  // Keep track of the frames-per-second counter.
  // Const value trick for old compilers.
  enum Constants { FRAMESARRAY_SIZE = 100 };
  double frames[FRAMESARRAY_SIZE];
  double totalval;
  double currentframetime;
  int framecount;

  // Misc
  SoType cameratype;
  SbBool cursoron, localsetbuffertype;
  SoCallbackList * interactionstartCallbacks, * interactionendCallbacks;
  int interactionnesting;
  SoGtkViewer::BufferType buffertype;
  SbBool stereoviewing;
  float stereooffset;

  void reallyRedraw(const SbBool clearcol, const SbBool clearz = TRUE);

  // Seek functionality
  static void seeksensorCB(void * data, SoSensor *);

  // Drawstyles
  void changeDrawStyle(SoGtkViewer::DrawStyle style);
  SbBool drawInteractiveAsStill(void) const;
  SbBool drawAsHiddenLine(void) const;
  SbBool drawAsWireframeOverlay(void) const;
  SoGtkViewer::DrawStyle currentDrawStyle(void) const;

  // Automatic setting of clipping planes
  void setClippingPlanes(void);

  // Methods to keep track of frames-per-second value.
  void resetFrameCounter(void);
  void addFrametime(const double ft);
  void recordFPS(const double rendertime);

  // Misc
  static void interactivestartCB(void *, SoGtkViewer * thisp);
  static void interactiveendCB(void *, SoGtkViewer * thisp);
  void moveCameraScreen(const SbVec2f & screenpos);
  void getCameraCoordinateSystem(SoCamera * camera, SoNode * root,
                                 SbMatrix & matrix, SbMatrix & inverse);

  SoSearchAction * searchaction;
  SoGetMatrixAction * matrixaction;
  SbPList * superimpositions;
  SbIntList * superimpositionsenabled;
  SoGtkViewer * pub;
};

SoGtkViewerP::SoGtkViewerP(SoGtkViewer * publ)
{
  this->pub = publ;
  this->searchaction = new SoSearchAction;
  this->matrixaction = new SoGetMatrixAction(SbViewportRegion(100,100));
  this->superimpositions = NULL;
  this->superimpositionsenabled = NULL;
} // SoGtkViewerP()

SoGtkViewerP::~SoGtkViewerP(void)
{
  if (this->superimpositions) {
    delete this->superimpositions;
    delete this->superimpositionsenabled;
    this->superimpositions = NULL;
  }
  delete this->searchaction;
  delete this->matrixaction;
}

SoSeparator *
SoGtkViewerP::createSuperScene(void)
{
  static const char * superSceneGraph[] =
  {
    "#Inventor V2.1 ascii",
    "",
    "Separator {",
    "  renderCaching OFF",
    "  renderCulling OFF",
    "  pickCulling OFF",
    "  boundingBoxCaching OFF",
    
    // Headlight. By inserting this before any scenegraph camera, the
    // light will always be pointing in the correct direction.
    "  DEF sogtk->headlight DirectionalLight {",
    "    direction 1 -1 -10",
    "  }",
    "  DEF sogtk->drawstyleroot Switch {",
    "    whichChild -1",
    "    DEF sogtk->lightmodel LightModel {",
    "      model BASE_COLOR",
    "    }",
    "    DEF sogtk->drawstyle DrawStyle {",
    "      pointSize ~",
    "      lineWidth ~",
    "      linePattern ~",
    "    }",
    "    DEF sogtk->complexity Complexity {",
    "      textureQuality 0.0",
    "      value 0.1",
    "    }",
    "  }",
    "  DEF sogtk->hiddenlineroot Switch {",
    "    whichChild -1",
    "    DEF sogtk->basecolor BaseColor { }",
    "    DEF sogtk->materialbinding MaterialBinding {",
    "      value OVERALL",
    "    }",
    "    DEF sogtk->polygonoffsetparent Switch {",
    "      whichChild -1",
#if HAVE_SOPOLYGONOFFSET
    "      DEF sogtk->polygonoffset PolygonOffset { }",
#endif // HAVE_SOPOLYGONOFFSET
    "    }",
    "  }",
    "  DEF sogtk->userscenegraphroot Separator {",
    "  }",
    "}",
    NULL
  };

  int i, bufsize;
  for (i = bufsize = 0; superSceneGraph[i]; i++)
    bufsize += strlen(superSceneGraph[i]) + 1;
  char * buf = new char [bufsize + 1];
  for (i = bufsize = 0; superSceneGraph[i]; i++) {
    strcpy(buf + bufsize, superSceneGraph[i]);
    bufsize += strlen(superSceneGraph[i]);
    buf[bufsize] = '\n';
    bufsize++;
  }
  SoInput * input = new SoInput;
  input->setBuffer(buf, bufsize);
  SoNode * root = NULL;
  SbBool ok = SoDB::read(input, root);
  delete input;
  delete [] buf;
  if (!ok) {
    SoDebugError::post("SoGtkViewer::SoGtkViewer",
		       "couldn't create viewer superscene");
    return NULL;
  }
  assert(root->isOfType(SoSeparator::getClassTypeId()));
  root->ref();

  this->searchaction->reset();
  this->searchaction->setSearchingAll(TRUE);
  this->searchaction->setInterest(SoSearchAction::FIRST);

#define LOCATE_NODE(member, type, name) \
  do { \
    member = NULL; \
    this->searchaction->setName(SbName(name)); \
    this->searchaction->apply(root); \
    if (this->searchaction->isFound()) { \
      SoNode * node = this->searchaction->getPath()->getTail(); \
      assert(node != NULL); \
      if (node->isOfType(type::getClassTypeId())) \
        member = (type *) node; \
    } else { \
      SoDebugError::post("SoGtkViewerP::createSuperScene", \
                         "didn't locate node \"%s\"", name); \
    } \
  } while (FALSE)

  LOCATE_NODE(this->headlight, SoDirectionalLight, "sogtk->headlight");
  LOCATE_NODE(this->drawstyleroot, SoSwitch, "sogtk->drawstyleroot");
  LOCATE_NODE(this->hiddenlineroot, SoSwitch, "sogtk->hiddenlineroot");
  LOCATE_NODE(this->polygonoffsetparent, SoSwitch,
	      "sogtk->polygonoffsetparent");
  LOCATE_NODE(this->usersceneroot, SoSeparator, "sogtk->userscenegraphroot");

  LOCATE_NODE(this->sobasecolor, SoBaseColor, "sogtk->basecolor");
  LOCATE_NODE(this->socomplexity, SoComplexity, "sogtk->complexity");
  LOCATE_NODE(this->sodrawstyle, SoDrawStyle, "sogtk->drawstyle");
  LOCATE_NODE(this->solightmodel, SoLightModel, "sogtk->lightmodel");
  LOCATE_NODE(this->somaterialbinding, SoMaterialBinding, "sogtk->materialbinding");
  if (this->sobasecolor) this->sobasecolor->setOverride(TRUE);
  if (this->socomplexity) this->socomplexity->setOverride(TRUE);
  if (this->sodrawstyle) this->sodrawstyle->setOverride(TRUE);
  if (this->solightmodel) this->solightmodel->setOverride(TRUE);
  if (this->somaterialbinding) this->somaterialbinding->setOverride(TRUE);
#ifdef HAVE_POLYGONOFFSET
  LOCATE_NODE(this->sopolygonoffset, SoPolygonOffset, "sogtk->polygonoffset");
  if (this->sopolygonoffset) this->sopolygonoffset->setOverride(TRUE);
#endif

#undef LOCATE_NODE
  this->searchaction->reset();

  root->unrefNoDelete();
  return (SoSeparator *) root;
}

SoSeparator *
SoGtkViewerP::createFPSSuperimposition(void)
{
  static const char * fpsSceneGraph[] =
  {
    "#Inventor V2.1 ascii",
    "",
    "Separator {",
    "  renderCaching OFF",
    "  renderCulling OFF",
    "  pickCulling OFF",
    "  boundingBoxCaching OFF",
    "}",
    NULL
  };

  int i, bufsize;
  for (i = bufsize = 0; fpsSceneGraph[i]; i++)
    bufsize += strlen(fpsSceneGraph[i]) + 1;
  char * buf = new char [bufsize + 1];
  for (i = bufsize = 0; fpsSceneGraph[i]; i++) {
    strcpy(buf + bufsize, fpsSceneGraph[i]);
    bufsize += strlen(fpsSceneGraph[i]);
    buf[bufsize] = '\n';
    bufsize++;
  }
  SoInput * input = new SoInput;
  input->setBuffer(buf, bufsize);
  SoNode * root = NULL;
  SbBool ok = SoDB::read(input, root);
  delete input;
  delete [] buf;
  if (!ok) {
    SoDebugError::post("SoGtkViewer::SoGtkViewer",
		       "couldn't create viewer superscene");
    return NULL;
  }
  assert(root->isOfType(SoSeparator::getClassTypeId()));
  root->ref();

  root->unrefNoDelete();
  return NULL;
  return (SoSeparator *) root;
}

// returns the camera coordinate system. Useful when there area
// transformations before the camera in the scene graph.
void
SoGtkViewerP::getCameraCoordinateSystem(SoCamera * camera,
                                          SoNode * root,
                                          SbMatrix & matrix,
                                          SbMatrix & inverse)
{
  this->searchaction->reset();
  this->searchaction->setSearchingAll(TRUE);
  this->searchaction->setInterest(SoSearchAction::FIRST);
  this->searchaction->setNode(camera);
  this->searchaction->apply(root);

  matrix = inverse = SbMatrix::identity();
  if (this->searchaction->getPath()) {
    this->matrixaction->apply(this->searchaction->getPath());
    matrix = this->matrixaction->getMatrix();
    inverse = this->matrixaction->getInverse();
  }
  this->searchaction->reset();
}


#define PRIVATE(ptr) (ptr->pimpl)

// *************************************************************************

SOGTK_OBJECT_ABSTRACT_SOURCE(SoGtkViewer);

// *************************************************************************

/*!
  \enum SoGtkViewer::Type

  Hints about what context the viewer will be used in.  Usually not
  very interesting for the application programmer, it doesn't matter
  much which value is used for the viewer type.  This "feature" of the
  viewer is included just to be compatible with the old SGI Inventor
  API.
*/
/*!
  \var SoGtkViewer::Type SoGtkViewer::BROWSER

  If a user-supplied scenegraph passed into the setSceneGraph()
  function does not contain a camera, setting the viewer type to
  BROWSER will make the viewer in that case automatically set up a
  camera outside the scene, as part of the viewer's private and hidden
  "supergraph".
*/
/*!
  \var SoGtkViewer::Type SoGtkViewer::EDITOR

  If a user-supplied scenegraph passed into the setSceneGraph)
  function does not contain a camera, setting the viewer type to
  EDITOR will make the viewer in that case automatically set up a
  camera \e in the user-supplied scene.

  So if you want to avoid having the SoGtkViewer class muck about
  with your supplied scenegraph, set the type-flag to
  SoGtkViewer::BROWSER instead.
*/

/*!
  \enum SoGtkViewer::DecimationStrategy
  FIXME: write documentation for enum
*/
/*!
  \var SoGtkViewer::DecimationStrategy SoGtkViewer::NORMAL
  FIXME: write documentation for enum definition
*/
/*!
  \var SoGtkViewer::DecimationStrategy SoGtkViewer::FIXED_NUM_TRIANGLES
  FIXME: write documentation for enum definition
*/
/*!
  \var SoGtkViewer::DecimationStrategy SoGtkViewer::FRAMES_PER_SECOND
  FIXME: write documentation for enum definition
*/
/*!
  \var SoGtkViewer::DecimationStrategy SoGtkViewer::FIXED_PERCENTAGE
  FIXME: write documentation for enum definition
*/

/*!
  \enum SoGtkViewer::DrawStyle
  FIXME: write documentation for enum
*/
/*!
  \var SoGtkViewer::DrawStyle SoGtkViewer::VIEW_AS_IS
  FIXME: write documentation for enum definition
*/
/*!
  \var SoGtkViewer::DrawStyle SoGtkViewer::VIEW_HIDDEN_LINE
  FIXME: write documentation for enum definition
*/
/*!
  \var SoGtkViewer::DrawStyle SoGtkViewer::VIEW_WIREFRAME_OVERLAY
  FIXME: write documentation for enum definition
*/
/*!
  \var SoGtkViewer::DrawStyle SoGtkViewer::VIEW_NO_TEXTURE
  FIXME: write documentation for enum definition
*/
/*!
  \var SoGtkViewer::DrawStyle SoGtkViewer::VIEW_LOW_COMPLEXITY
  FIXME: write documentation for enum definition
*/
/*!
  \var SoGtkViewer::DrawStyle SoGtkViewer::VIEW_LINE
  FIXME: write documentation for enum definition
*/
/*!
  \var SoGtkViewer::DrawStyle SoGtkViewer::VIEW_POINT
  FIXME: write documentation for enum definition
*/
/*!
  \var SoGtkViewer::DrawStyle SoGtkViewer::VIEW_BBOX
  FIXME: write documentation for enum definition
*/
/*!
  \var SoGtkViewer::DrawStyle SoGtkViewer::VIEW_LOW_RES_LINE
  FIXME: write documentation for enum definition
*/
/*!
  \var SoGtkViewer::DrawStyle SoGtkViewer::VIEW_LOW_RES_POINT
  FIXME: write documentation for enum definition
*/
/*!
  \var SoGtkViewer::DrawStyle SoGtkViewer::VIEW_SAME_AS_STILL
  FIXME: write documentation for enum definition
*/

/*!
  \enum SoGtkViewer::DrawType
  FIXME: write documentation for enum
*/
/*!
  \var SoGtkViewer::DrawType SoGtkViewer::STILL
  FIXME: write documentation for enum definition
*/
/*!
  \var SoGtkViewer::DrawType SoGtkViewer::INTERACTIVE
  FIXME: write documentation for enum definition
*/

/*!
  \enum SoGtkViewer::BufferType
  FIXME: write documentation for enum
*/
/*!
  \var SoGtkViewer::BufferType SoGtkViewer::BUFFER_SINGLE
  FIXME: write documentation for enum definition
*/
/*!
  \var SoGtkViewer::BufferType SoGtkViewer::BUFFER_DOUBLE
  FIXME: write documentation for enum definition
*/
/*!
  \var SoGtkViewer::BufferType SoGtkViewer::BUFFER_INTERACTIVE
  FIXME: write documentation for enum definition
*/

/*!
  \var SoCamera * SoGtkViewer::camera

  Pointer to the viewer camera.
*/

/*!
  \var SoGtkViewer::Type SoGtkViewer::type

  (Just included for compatibility reasons. Can safely be ignored.)
*/

/*!
  \var SbBool SoGtkViewer::viewingFlag

  Whether the viewer is in view mode or not.
*/

/*!
  \var SoSeparator * SoGtkViewer::sceneRoot

  The root of the viewer scene graph.
*/

/*!
  \var SoNode * SoGtkViewer::sceneGraph

  The root of the user scene graph.
*/

/*!
  \var SbBool SoGtkViewer::altSwitchBack

  Flag on returning from alt in pick mode?
*/

/*!
  \var SoGetBoundingBoxAction SoGtkViewer::autoClipBboxAction

  Action for getting the scene bounding box, for setting the clip planes.
*/

/*!
  \var float SoGtkViewer::minimumNearPlane

  Percentage of distance to far plane for distance to near plane.
*/

// *************************************************************************

/*!
  \internal

  Return the parent node in the scene graph of the given \a node.
  NB: this is just a quick'n'dirty thing for often executed code,
  and doesn't cover cases where nodes have multiple parents.
*/

static SoGroup *
get_parent_of_node(SoGtkViewerP * pimpl, SoNode * root, SoNode * node)
{
  SbBool oldsearch = SoBaseKit::isSearchingChildren();
  SoBaseKit::setSearchingChildren(TRUE);

  assert(node && root && "get_parent_of_node() called with null argument");
  if (pimpl == NULL) {
    SoSearchAction search;
    search.setSearchingAll(TRUE);
    search.setNode(node);
    search.apply(root);
    assert(search.getPath() && "node not found in scenegraph");
    SoNode * parent = ((SoFullPath *)search.getPath())->getNodeFromTail(1);
    assert(parent && "couldn't find parent");
    SoBaseKit::setSearchingChildren(oldsearch);
    return (SoGroup *)parent;
  } else {
    pimpl->searchaction->reset();
    pimpl->searchaction->setSearchingAll(TRUE);
    pimpl->searchaction->setNode(node);
    pimpl->searchaction->apply(root);
    assert(pimpl->searchaction->getPath() && "node not found in scenegraph");
    SoNode * parent =
      ((SoFullPath *) pimpl->searchaction->getPath())->getNodeFromTail(1);
    assert(parent && "couldn't find parent");
    pimpl->searchaction->reset();
    SoBaseKit::setSearchingChildren(oldsearch);
    return (SoGroup *)parent;
  }
}

// *************************************************************************

/*!
  Constructor. \a parent, \a name and \a embed are passed on to
  SoGtkRenderArea, so see the documentation for our parent
  constructor for for more information on those.

  The \a t type setting hints about what context the viewer will be
  used in.  Usually not very interesting for the application
  programmer, but if you want to make sure the SoGtkViewer class
  doesn't muck about with your supplied scenegraph, set the type-flag
  to SoGtkViewer::BROWSER.  (This "feature" of the viewer is
  included just to be compatible with the old SGI Inventor API.)

  The \a build flag decides whether or not to delay building the
  widgets / window which is going to make up the components of the
  viewer.
*/
SoGtkViewer::SoGtkViewer(GtkWidget * parent,
                             const char * name,
                             SbBool embed,
                             SoGtkViewer::Type t,
                             SbBool build)
  : inherited(parent, name, embed, TRUE, TRUE, FALSE)
{
  PRIVATE(this) = new SoGtkViewerP(this);

  // initialization of protected data
  this->type = t;
  this->viewingFlag = TRUE;
  this->camera = NULL;
  this->altSwitchBack = FALSE;
  this->sceneGraph = NULL;

  // initialization of internal data
  PRIVATE(this)->cursoron = TRUE;
  PRIVATE(this)->localsetbuffertype = FALSE;

  PRIVATE(this)->cameratype = SoPerspectiveCamera::getClassTypeId();
  PRIVATE(this)->deletecamera = FALSE;
  PRIVATE(this)->buffertype = this->isDoubleBuffer() ? BUFFER_DOUBLE : BUFFER_SINGLE;

  PRIVATE(this)->interactionstartCallbacks = new SoCallbackList;
  PRIVATE(this)->interactionendCallbacks = new SoCallbackList;
  PRIVATE(this)->interactionnesting = 0;

  PRIVATE(this)->seekdistance = 50.0f;
  PRIVATE(this)->seekdistanceabs = FALSE;
  PRIVATE(this)->seektopoint = TRUE;
  PRIVATE(this)->seekperiod = 2.0f;
  PRIVATE(this)->inseekmode = FALSE;
  PRIVATE(this)->seeksensor = new SoTimerSensor(SoGtkViewerP::seeksensorCB, this);

  this->sceneRoot = PRIVATE(this)->createSuperScene();
  this->sceneRoot->ref();

  PRIVATE(this)->drawstyles[STILL] = VIEW_AS_IS;
  PRIVATE(this)->drawstyles[INTERACTIVE] = VIEW_SAME_AS_STILL;

  this->addStartCallback(SoGtkViewerP::interactivestartCB);
  this->addFinishCallback(SoGtkViewerP::interactiveendCB);

  PRIVATE(this)->adjustclipplanes = TRUE;
  this->autoClipBboxAction = NULL;

  PRIVATE(this)->stereoviewing = FALSE;
  PRIVATE(this)->stereooffset = 0.1f;

  if (build) {
    this->setClassName("SoGtkViewer");
    GtkWidget * widget = this->buildWidget(this->getParentWidget());
    this->setBaseWidget(widget);
  }

  PRIVATE(this)->fpsRoot = PRIVATE(this)->createFPSSuperimposition();
  if (PRIVATE(this)->fpsRoot) {
    this->addSuperimposition(PRIVATE(this)->fpsRoot);
    this->setSuperimpositionEnabled(PRIVATE(this)->fpsRoot, FALSE);
  }
  PRIVATE(this)->resetFrameCounter();
} // SoGtkViewer()

// *************************************************************************

/*!
  Destructor.
*/

SoGtkViewer::~SoGtkViewer(
  void)
{
  delete this->autoClipBboxAction;

  delete PRIVATE(this)->interactionstartCallbacks;
  delete PRIVATE(this)->interactionendCallbacks;

  delete PRIVATE(this)->seeksensor;

  if (this->sceneGraph) this->setSceneGraph(NULL);
  this->sceneRoot->unref();
  if (PRIVATE(this)->superimpositions != NULL) {
    for (int i = PRIVATE(this)->superimpositions->getLength() - 1; i >= 0; i--) {
      SoNode * node = (SoNode *) (*PRIVATE(this)->superimpositions)[i];
      node->unref();
    }
  }
  delete PRIVATE(this);
} // ~SoGtkViewer()

// *************************************************************************

/*!
  Set the camera we want to view the scene with.

  The camera passed in as an argument to this method must be part of
  the viewer's scenegraph.

  \sa getCamera()
*/

void
SoGtkViewer::setCamera(SoCamera * cam)
{
  if (this->camera) {
    // If we made the camera, detach it. Otherwise just leave it in
    // the graph.
    if (PRIVATE(this)->deletecamera) {
      SoGroup * cameraparent =
	get_parent_of_node(PRIVATE(this), this->sceneRoot, this->camera);
      cameraparent->removeChild(this->camera);
      PRIVATE(this)->deletecamera = FALSE;
    }

    this->camera->unref();
  }

  this->camera = cam;

  if (this->camera) {
    this->camera->ref();
    this->saveHomePosition();
    PRIVATE(this)->cameratype = this->camera->getTypeId();
  }
} // setCamera()

// *************************************************************************

/*!
  Returns the camera currently used by the viewer for the user's main
  viewpoint.

  It \e is possible that this function returns \c NULL, for instance
  if there's no scenegraph present in the viewer.  (This is mostly
  meant as a note for developers extending the SoGtk library, as
  application programmers usually controls if and when a viewer
  contains a scenegraph, and therefore know in advance if this method
  will return a valid camera pointer.)

  \sa setCamera()
*/

SoCamera *
SoGtkViewer::getCamera(void) const
{
  return this->camera;
} // getCamera()

// *************************************************************************

/*!
  When the viewer has to make its own camera as a result of the graph
  passed to setSceneGraph() not containing any camera nodes, this call
  can be made in advance to decide which type the camera will be of.

  Default is to use an SoPerspectiveCamera.

  If this method is called when there is a scene graph and a camera
  already set up, it will delete the old camera and set up a camera
  with the new type if the \a t type is different from that of the
  current camera.

  \sa getCameraType()
*/

void
SoGtkViewer::setCameraType(SoType t)
{
  SoType perspectivetype = SoPerspectiveCamera::getClassTypeId();
  SoType orthotype = SoOrthographicCamera::getClassTypeId();
  SbBool oldisperspective = PRIVATE(this)->cameratype.isDerivedFrom(perspectivetype);
  SbBool newisperspective = t.isDerivedFrom(perspectivetype);

  if ((oldisperspective && newisperspective) ||
       (!oldisperspective && !newisperspective)) // Same old, same old..
    return;

  if (SOGTK_DEBUG) {
    SbBool valid = TRUE;
    if (t == SoType::badType()) valid = FALSE;
    if (valid) {
      valid = FALSE;
      if (newisperspective) valid = TRUE;
      if (t.isDerivedFrom(orthotype)) valid = TRUE;
    }

    if (!valid) {
      SoDebugError::post("SoGtkViewer::setCameraType",
                         "not a valid camera type: '%s'",
                         t == SoType::badType() ?
                         "badType" : t.getName().getString());
      return;
    }
  }

  if (this->camera != NULL) {
    SoCamera * newcamera = (SoCamera *)t.createInstance();
    newcamera->aspectRatio.setValue(this->camera->aspectRatio.getValue());
    newcamera->focalDistance.setValue(this->camera->focalDistance.getValue());
    newcamera->orientation.setValue(this->camera->orientation.getValue());
    newcamera->position.setValue(this->camera->position.getValue());
    newcamera->viewportMapping.setValue(this->camera->viewportMapping.getValue());

    SoPerspectiveCamera * newpcam = NULL, * oldpcam = NULL;
    SoOrthographicCamera * newocam = NULL, * oldocam = NULL;

    float focaldist = this->camera->focalDistance.getValue();

    if (newisperspective) {
      newpcam = (SoPerspectiveCamera *)newcamera;
      oldocam = (SoOrthographicCamera *)this->camera;

      // focalDistance==0.0f happens for empty scenes.
      if (focaldist != 0.0f) {
        newpcam->heightAngle =
          2.0f * atan(oldocam->height.getValue() / 2.0f / focaldist);
      }
      else {
        newpcam->heightAngle = 0.0f;
      }
    }
    else {
      newocam = (SoOrthographicCamera *)newcamera;
      oldpcam = (SoPerspectiveCamera *)this->camera;
      newocam->height =
        2 * focaldist * tan(oldpcam->heightAngle.getValue() / 2.0f);
    }

    SoGroup * cameraparent =
      get_parent_of_node(PRIVATE(this), this->sceneRoot, this->camera);
    cameraparent->insertChild(newcamera,
                               cameraparent->findChild(this->camera));
    SoCamera * oldcamera = !PRIVATE(this)->deletecamera ? this->camera : NULL;
    this->setCamera(newcamera); // This will set PRIVATE(this)->cameratype.
    PRIVATE(this)->deletecamera = TRUE;
    if (oldcamera) { cameraparent->removeChild(oldcamera); }
  }
  else { // A camera has not been instantiated for the scene.
    PRIVATE(this)->cameratype = t; // No call to setCamera(), so set type explicitly.
  }
} // setCameraType()

// *************************************************************************

/*!
  Returns camera type which will be used when the viewer has to make its
  own camera.

  Note that this call does \e not return the current cameratype, as one
  might expect. Use getCamera() and SoType::getTypeId() for that inquiry.

  \sa setCameraType()
*/

SoType
SoGtkViewer::getCameraType(void) const
{
  return PRIVATE(this)->cameratype;
} // getCameraType()

// *************************************************************************

/*!
  Reposition the current camera so we can see the complete scene.
*/

void
SoGtkViewer::viewAll(void)
{
  if (this->camera && this->sceneGraph)
    this->camera->viewAll(this->sceneGraph, this->getViewportRegion());
} // viewAll()

// *************************************************************************

/*!
  Store the current camera settings for later retrieval with
  resetToHomePosition().

  \sa resetToHomePosition()
*/

void
SoGtkViewer::saveHomePosition(void)
{
  if (! this->camera) return; // probably a scene-less viewer

  PRIVATE(this)->storedorientation = this->camera->orientation.getValue();
  PRIVATE(this)->storedposition = this->camera->position.getValue();

  SoType t = this->camera->getTypeId();
  if (t.isDerivedFrom(SoOrthographicCamera::getClassTypeId())) {
    PRIVATE(this)->storedheightval =
      ((SoOrthographicCamera *)this->camera)->height.getValue();
  }
  else if (t.isDerivedFrom(SoPerspectiveCamera::getClassTypeId())) {
    PRIVATE(this)->storedheightval =
      ((SoPerspectiveCamera *)this->camera)->heightAngle.getValue();
  }
} // saveHomePosition()

// *************************************************************************

/*!
  Restore the saved camera settings.

  \sa saveHomePosition()
*/

void
SoGtkViewer::resetToHomePosition(void)
{
  if (! this->camera) return; // probably a scene-less viewer

  this->camera->orientation = PRIVATE(this)->storedorientation;
  this->camera->position = PRIVATE(this)->storedposition;

  SoType t = this->camera->getTypeId();
  if (t.isDerivedFrom(SoOrthographicCamera::getClassTypeId()))
    ((SoOrthographicCamera *)this->camera)->height = PRIVATE(this)->storedheightval;
  else if (t.isDerivedFrom(SoPerspectiveCamera::getClassTypeId()))
    ((SoPerspectiveCamera *)this->camera)->heightAngle = PRIVATE(this)->storedheightval;

  PRIVATE(this)->setClippingPlanes();
  this->camera->focalDistance =
    (this->camera->farDistance.getValue() +
     this->camera->nearDistance.getValue())/2;
} // resetToHomePosition()

// *************************************************************************

/*!
  Turn the camera headlight on or off.

  Default is to have a headlight turned on.

  \sa isHeadlight(), getHeadlight()
*/

void
SoGtkViewer::setHeadlight(SbBool on)
{
  PRIVATE(this)->headlight->on = on;
} // setHeadlight()

// *************************************************************************

/*!
  Returns status of the viewer headlight, whether it is on or off.

  \sa setHeadlight(), getHeadlight()
*/

SbBool
SoGtkViewer::isHeadlight(void) const
{
  return PRIVATE(this)->headlight->on.getValue();
} // isheadlight()

// *************************************************************************

/*!
  Returns the a pointer to the directional light node which is the
  viewer headlight.

  The fields of the node is available for user editing.

  \sa isHeadlight(), setHeadlight()
*/

SoDirectionalLight *
SoGtkViewer::getHeadlight(void) const
{
  return PRIVATE(this)->headlight;
} // getHeadlight()

// *************************************************************************

/*!
  Set up a drawing style. The \a type argument specifies if the given
  \a style should be interpreted as the drawstyle during animation or
  when the camera is static.

  Default values for the drawing style is to render the scene "as is"
  in both still mode and while the camera is moving.

  See the documentation for the \a DrawType and \a DrawStyle for more
  information.

  \sa getDrawStyle()
*/

void
SoGtkViewer::setDrawStyle(SoGtkViewer::DrawType type,
                            SoGtkViewer::DrawStyle style)
{
  if (SOGTK_DEBUG) {
    if ((type != STILL) && (type != INTERACTIVE)) {
      SoDebugError::postWarning("SoGtkViewer::setDrawStyle",
                                "unknown drawstyle type setting 0x%x", type);
      return;
    }
  }

  if (style == this->getDrawStyle(type)) {
    if (SOGTK_DEBUG && 0) { // debug
      SoDebugError::postWarning("SoGtkViewer::setDrawStyle",
                                "drawstyle for type 0x%02x already 0x%02x",
                                type, style);
    }
    return;
  }

  PRIVATE(this)->drawstyles[type] = style;
  PRIVATE(this)->changeDrawStyle(PRIVATE(this)->currentDrawStyle());
} // setDrawStyle()

// *************************************************************************

/*!
  Return current drawstyles for the given type (\a STILL or
  \a INTERACTIVE).

  \sa setDrawStyle()
*/

SoGtkViewer::DrawStyle
SoGtkViewer::getDrawStyle(const SoGtkViewer::DrawType type) const
{
  if (SOGTK_DEBUG) {
    if ((type != STILL) && (type != INTERACTIVE)) {
      SoDebugError::postWarning("SoGtkViewer::setDrawStyle",
                                "unknown drawstyle type setting 0x%x", type);
      return PRIVATE(this)->drawstyles[STILL];
    }
  }

  return PRIVATE(this)->drawstyles[type];
} // getDrawStyle()

// *************************************************************************

/*!
  Set the viewer's buffer type. Available types are \c
  SoGtkViewer::BUFFER_SINGLE, \c SoGtkViewer::BUFFER_DOUBLE and \c
  SoGtkViewer::BUFFER_INTERACTIVE.

  (With a buffer type of \c SoGtkViewer::BUFFER_INTERACTIVE, the
  viewer will render with doublebuffering during user interaction and
  with single buffering otherwise.)

  Default is \c SoGtkViewer::BUFFER_DOUBLE.

  \sa getBufferingType()
*/

void
SoGtkViewer::setBufferingType(SoGtkViewer::BufferType type)
{
  if (type == PRIVATE(this)->buffertype) return;

  if (type != BUFFER_SINGLE &&
      type != BUFFER_DOUBLE &&
      type != BUFFER_INTERACTIVE) {
    if (SOGTK_DEBUG) {
      SoDebugError::postWarning("SoGtkViewer::setBufferingType",
                                "unknown buffer type 0x%x", type);
    }
    return;
  }

  PRIVATE(this)->buffertype = type;

  PRIVATE(this)->localsetbuffertype = TRUE;
  inherited::setDoubleBuffer(type == BUFFER_DOUBLE);
  PRIVATE(this)->localsetbuffertype = FALSE;
} // setBufferingType()

// *************************************************************************

/*!
  Return the viewer's buffer type.

  \sa setBufferingType()
*/

SoGtkViewer::BufferType
SoGtkViewer::getBufferingType(void) const
{
  return PRIVATE(this)->buffertype;
} // getBufferingType()

// *************************************************************************

// Note: this documentation for setViewing() will also be used for all
// the miscellaneous viewer subclasses, so keep it general.
/*!
  Set view mode.

  If the view mode is on, user events will be caught and used to
  influence the camera position / orientation. If view mode is off,
  all events in the viewer canvas (like for instance keypresses or
  mouseclicks and -movements) will be passed along to the scene graph.

  Default is to have the view mode active.

  \sa getViewing()
*/
void
SoGtkViewer::setViewing(SbBool enable)
{
  if (this->viewingFlag == enable) {
    if (SOGTK_DEBUG) {
      SoDebugError::postWarning("SoGtkViewer::setViewing",
                                "unnecessary called");
    }
    return;
  }

  this->viewingFlag = enable;

  // Turn off the selection indicators when we go back from picking
  // mode into viewing mode.
  if (this->viewingFlag) {
    SoGLRenderAction * action = this->getGLRenderAction();
    if (action != NULL)
      SoLocateHighlight::turnOffCurrentHighlight(action);
  }
} // setViewing()

// *************************************************************************

/*!
  Return state of view mode.

  \c TRUE means that the mode of the viewer is set such that user
  interaction with the mouse is used to modify the position and
  orientation of the camera.

  \sa setViewing()
*/
SbBool
SoGtkViewer::isViewing(void) const
{
  return this->viewingFlag;
}

// *************************************************************************

/*!
  Set whether or not the mouse cursor representation should be visible
  in the viewer canvas.

  Default value is on.

  \sa getCursorEnabled()
*/

void
SoGtkViewer::setCursorEnabled(SbBool on)
{
  PRIVATE(this)->cursoron = on;
} // setCursorEnabled()

// *************************************************************************

/*!
  Returns visibility status of mouse cursor.

  \sa setCursorEnabled()
*/

SbBool
SoGtkViewer::isCursorEnabled(void) const
{
  return PRIVATE(this)->cursoron;
} // isCursorEnabled()

// *************************************************************************

/*!
  Turn on or off continuous automatic adjustments of the near
  and far clipping planes.

  Automatic clipping is on as default.

  \sa getAutoClipping()
*/

void
SoGtkViewer::setAutoClipping(
  SbBool enable)
{
  if (SOGTK_DEBUG) {
    if (PRIVATE(this)->adjustclipplanes == enable) {
      SoDebugError::postWarning("SoGtkViewer::setAutoClipping",
                                "unnecessary called");
      return;
    }
  }

  PRIVATE(this)->adjustclipplanes = enable;
  if (enable) { this->scheduleRedraw(); }
} // setAutoClipping()

// *************************************************************************

/*!
  Return value of the automatic near/far clipplane adjustment indicator.

  \sa setAutoClipping()
*/

SbBool
SoGtkViewer::isAutoClipping(
  void) const
{
  return PRIVATE(this)->adjustclipplanes;
} // isAutoClipping()

// *************************************************************************

/*!
  Turn stereo viewing on or off.

  \sa isStereoViewing()
*/

void
SoGtkViewer::setStereoViewing(// virtual
  SbBool enable)
{
  PRIVATE(this)->stereoviewing = enable;
  this->scheduleRedraw();
} // setStereoViewing()

// *************************************************************************

/*!
  Returns a boolean indicating whether or not we're in stereo viewing
  mode.

  NOTE: in the original InventorXt API, this method was virtual.  It is not
  virtual here.

  \sa setStereoViewing()
*/

SbBool
SoGtkViewer::isStereoViewing(
  void) const
{
  return PRIVATE(this)->stereoviewing;
} // setStereoViewing()

// *************************************************************************

/*!
  Set the offset between the two viewpoints when in stereo mode.

  NOTE: In the original InventorXt API, this method was not virtual.

  \sa getStereoOffset()
*/

void
SoGtkViewer::setStereoOffset(// virtual
  const float dist)
{
  PRIVATE(this)->stereooffset = dist;
  this->scheduleRedraw();
} // setStereoOffset()

/*!
  Return the offset distance between the two viewpoints when in stereo mode.

  \sa setStereoOffset()
*/

float
SoGtkViewer::getStereoOffset(
  void) const
{
  return PRIVATE(this)->stereooffset;
} // getStereoOffset()

// *************************************************************************

/*!
  Toggle between seeking to a point or seeking to an object.

  Default is to seek to a point.

  \sa isDetailSeek()
*/

void
SoGtkViewer::setDetailSeek(const SbBool on)
{
  if (SOGTK_DEBUG) {
    if (PRIVATE(this)->seektopoint == on) {
      SoDebugError::postWarning("SoGtkViewer::setDetailSeek",
                                "unnecessary called");
      return;
    }
  }

  PRIVATE(this)->seektopoint = on;
} // setDetailSeek()

// *************************************************************************

/*!
  Returns a value indicating whether or not seeks will be performed
  to the exact point of picking or just towards the picked object.

  \sa setDetailSeek()
*/

SbBool
SoGtkViewer::isDetailSeek(void) const
{
  return PRIVATE(this)->seektopoint;
} // isDetailSeek()

// *************************************************************************

/*!
  Set the duration of animating the camera repositioning
  after a successful seek. Call with \a seconds equal to \a 0.0 to make
  the camera jump immediately to the correct spot.

  Default value is 2 seconds.

  \sa getSeekTime()
*/

void
SoGtkViewer::setSeekTime(const float seconds)
{
  if (seconds < 0.0f) {
    if (SOGTK_DEBUG) {
      SoDebugError::postWarning("SoGtkViewer::setSeekTime",
                                "an attempt was made to set a negative seek "
                                "time duration");
    }
    return;
  }
  PRIVATE(this)->seekperiod = seconds;
} // setSeekTime()

// *************************************************************************

/*!
  Returns the camera repositioning duration following a seek action.

  \sa setSeekTime()
*/

float
SoGtkViewer::getSeekTime(void) const
{
  return PRIVATE(this)->seekperiod;
} // getSeekTime()

// *************************************************************************

/*!
  Add a function to call when user interaction with the scene starts.

  \sa removeStartCallback(), addFinishCallback()
*/

void
SoGtkViewer::addStartCallback(SoGtkViewerCB * func, void * data)
{
  PRIVATE(this)->interactionstartCallbacks->addCallback((SoCallbackListCB *)func, data);
} // addStartCallback()

/*!
  Remove one of the functions which has been set up to be called when user
  interaction with the scene starts.

  \sa addStartCallback(), removeFinishCallback()
*/

void
SoGtkViewer::removeStartCallback(SoGtkViewerCB * func, void * data)
{
  PRIVATE(this)->interactionstartCallbacks->removeCallback((SoCallbackListCB *)func,
                                                  data);
} // removeStartCallback()

// *************************************************************************

/*!
  Add a function to call when user interaction with the scene ends.

  \sa removeFinishCallback(), addStartCallback()
*/

void
SoGtkViewer::addFinishCallback(SoGtkViewerCB * func, void * data)
{
  PRIVATE(this)->interactionendCallbacks->addCallback((SoCallbackListCB *)func, data);
} // addFinishCallback()

/*!
  Remove one of the functions which has been set up to be called when user
  interaction with the scene ends.

  \sa addFinishCallback(), removeStartCallback()
*/

void
SoGtkViewer::removeFinishCallback(SoGtkViewerCB * func, void * data)
{
  PRIVATE(this)->interactionendCallbacks->removeCallback((SoCallbackListCB *)func,
                                                data);
} // removeFinishCallback()

// *************************************************************************

/*!
  Copy the current camera to the system clipboard. This makes it
  easy to synchronize camera settings over different applications.

  Note: has not been implemented yet.

  \sa pasteView()
*/

void
SoGtkViewer::copyView(const SbTime eventTime)
{
  // FIXME: Needs SoGtkClipboard implementation first. 19990507 mortene.
  SOGTK_STUB();
} // copyView()

// *************************************************************************

/*!
  Set a new camera from the system clipboard.

  Note: has not been implemented yet.

  \sa copyView()
*/

void
SoGtkViewer::pasteView(const SbTime eventTime)
{
  // FIXME: Needs SoGtkClipboard implementation first. 19990507 mortene.
  SOGTK_STUB();
} // pasteView()

// *************************************************************************

/*!
  Not used, only included for compatibility reasons.
*/

void
SoGtkViewer::recomputeSceneSize(
  void)
{
  // FIXME: implement and use SOGTK_OBSOLETED(). 20010815 mortene.
  SoDebugError::postInfo("SoGtkViewer::recomputeSceneSize",
                         "this method is obsoleted, don't use it");
} // recomputeSceneSize()

// *************************************************************************

/*!
  Large Model Visualization; not implemented yet.
*/

void
SoGtkViewer::setDecimationStrategy(const SoGtkViewer::DecimationStrategy /*strategy*/)
{
  SOGTK_STUB();
} // setDecimationStrategy()

// *************************************************************************

/*!
  Large Model Visualization; not implemented yet.
*/

SoGtkViewer::DecimationStrategy
SoGtkViewer::getDecimationStrategy(void) const
{
  SOGTK_STUB();
  return NORMAL;
}

// *************************************************************************

/*!
  Large Model Visualization; not implemented yet.
*/

void
SoGtkViewer::setGoalNumberOfTriangles(const int32_t /*goal*/)
{
  SOGTK_STUB();
} // setGoalNumberOfTriangles()

// *************************************************************************

/*!
  Large Model Visualization; not implemented yet.
*/

int32_t
SoGtkViewer::getGoalNumberOfTriangles(void) const
{
  SOGTK_STUB();
  return -1;
} // getGoalNumberOfTriangles()

// *************************************************************************

/*!
  Large Model Visualization; not implemented yet.
*/

void
SoGtkViewer::setGoalFramesPerSecond(const float /*goal*/)
{
  SOGTK_STUB();
} // setGoalFramesPerSecond()

// *************************************************************************

/*!
  Large Model Visualization; not implemented yet.
*/

float
SoGtkViewer::getGoalFramesPerSecond(void) const
{
  SOGTK_STUB();
  return 72.0f;
} // getGoalFramesPerSecond()

// *************************************************************************

/*!
  Large Model Visualization; not implemented yet.
*/

void
SoGtkViewer::setFixedPercentage(const float /*percent*/)
{
  SOGTK_STUB();
} // setFixedPercentage()

// *************************************************************************

/*!
  Large Model Visualization; not implemented yet.
*/

float
SoGtkViewer::getFixedPercentage(void) const
{
  SOGTK_STUB();
  return 100.0f;
} // getFixedPercentage()

// *************************************************************************

/*!
  Large Model Visualization; not implemented yet.
*/

void
SoGtkViewer::enableFullRenderingWhenStill(const SbBool /*on*/)
{
  SOGTK_STUB();
} // enableFullRendering()

// *************************************************************************

/*!
  Large Model Visualization; not implemented yet.
*/

SbBool
SoGtkViewer::isFullRenderingWhenStill(void) const
{
  SOGTK_STUB();
  return TRUE;
} // isFullRendering()

/*!
  Large Model Visualization; not implemented yet.
*/

SbBool
SoGtkViewer::isStillNow(void) const
{
  SOGTK_STUB();
  return this->getInteractiveCount() == 0;
} // isStillNow()

// *************************************************************************

/*!
  Large Model Visualization; not implemented yet.
*/

void
SoGtkViewer::setFramesPerSecondCallback(SoGtkViewerFPSCB * /*callback*/, void * /*data*/)
{
  SOGTK_STUB();
} // setFramesPerSecond()

// *************************************************************************

/*!
  Large Model Visualization; not implemented yet.
*/

void
SoGtkViewer::setNumSamples(const int /*numFrames*/)
{
  SOGTK_STUB();
} // setNumSamples()

// *************************************************************************

/*!
  Large Model Visualization; not implemented yet.
*/

int
SoGtkViewer::getNumSamples(void) const
{
  SOGTK_STUB();
  return 10;
} // getNumSamples()

// *************************************************************************

/*!
  Large Model Visualization; not implemented yet.
*/

void
SoGtkViewer::setDecimationPercentageCallback(SoGtkViewerDecimationPercentageCB * /*cb*/, void * /*data*/)
{
  SOGTK_STUB();
} // setDecimationPercentageCallback()

// *************************************************************************

/*!
  Large Model Visualization; not implemented yet.
*/

float
SoGtkViewer::getCurrentDecimationPercentage(void) const
{
  SOGTK_STUB();
  return 100.0f;
} // getCurrentDecimateionPercentage()

// *************************************************************************

/*!
  Overloaded to update the local bufferingtype variable.

  \sa setBufferingType(), getBufferingType()
*/

void
SoGtkViewer::setDoubleBuffer(const SbBool on)
{
  if (!PRIVATE(this)->localsetbuffertype)
    PRIVATE(this)->buffertype = on ? BUFFER_DOUBLE : BUFFER_SINGLE;

  inherited::setDoubleBuffer(on);
} // setDoubleBuffer()

// *************************************************************************

/*!
  Give the viewer a scenegraph to render and interact with. Overloaded
  from parent class so the viewer can add it's own nodes to control
  rendering in different styles, rendering with a headlight, etc.

  The \a root node will be inserted under the \e viewer's root node,
  which also covers the nodes necessary to implement the different
  preferences drawing style settings.

  If no camera is part of the scene graph under \a root, one will be
  added automatically.

  \sa getSceneGraph(), setCameraType()
*/

void
SoGtkViewer::setSceneGraph(SoNode * root)
{
  if (root == this->sceneGraph) {
    if (SOGTK_DEBUG) {
      SoDebugError::postWarning("SoGtkViewer::setSceneGraph",
                                "called with the same root as already set");
    }
    return;
  }

  // If the SoGtkRenderArea hasn't yet set up its pointer to the
  // SoGtkViewer "viewer root" (i.e. the viewer-generated root above
  // the user-supplied root), do that first.
  if (!inherited::getSceneGraph())
    inherited::setSceneGraph(this->sceneRoot);

  if (this->sceneGraph) {
    if (this->getCamera())
      this->setCamera(NULL);
    // Release the old user-supplied graph.
    PRIVATE(this)->usersceneroot->removeChild(this->sceneGraph);
    // old: this->sceneRoot->removeChild(this->sceneGraph);
  }

  this->sceneGraph = root;
  if (!root) return;

  PRIVATE(this)->usersceneroot->addChild(this->sceneGraph);
  // old: this->sceneRoot->addChild(this->sceneGraph);

  // Search for a camera in the user-supplied scenegraph.
  // SoSearchAction search;
  // search.setType(SoCamera::getClassTypeId());
  // search.apply(this->sceneGraph);
  SbBool oldsearch = SoBaseKit::isSearchingChildren();
  SoBaseKit::setSearchingChildren(TRUE);

  PRIVATE(this)->searchaction->reset();
  PRIVATE(this)->searchaction->setType(SoCamera::getClassTypeId());
  PRIVATE(this)->searchaction->apply(this->sceneGraph);

  SoBaseKit::setSearchingChildren(oldsearch);

  SoCamera * scenecamera = NULL;
  if (PRIVATE(this)->searchaction->isFound()) {
    SoFullPath * fullpath =
      (SoFullPath *) PRIVATE(this)->searchaction->getPath();
    scenecamera = (SoCamera *)fullpath->getTail();
  }

#if 0 // debug
  SoDebugError::postInfo("SoGtkViewer::setSceneGraph",
                         "camera %sfound in graph",
                         scenecamera ? "" : "not ");
#endif // debug

  // Make our own camera if none was available.
  if (!scenecamera) {
    scenecamera = (SoCamera *) PRIVATE(this)->cameratype.createInstance();
    PRIVATE(this)->deletecamera = TRUE;

    // If type==BROWSER, camera should be inserted in the private
    // viewer "supergraph", if it's equal to EDITOR it should be
    // inserted in the user-supplied scenegraph.
    if (this->type == SoGtkViewer::BROWSER) {
      this->sceneRoot->insertChild(scenecamera, 1);
    }
    else { // this->type == SoGtkViewer::EDITOR
      if (this->sceneGraph->isOfType(SoGroup::getClassTypeId())) {
        // At the uppermost leftmost position in the user-supplied
        // scenegraph.
        ((SoGroup *)this->sceneGraph)->insertChild(scenecamera, 0);
      }
      else {
        // Make an extra depth level to fit the camera node into the
        // user-scenegraph.
        SoGroup * g = new SoGroup;
        g->addChild(scenecamera);
        g->addChild(this->sceneGraph);
        PRIVATE(this)->usersceneroot->removeChild(this->sceneGraph);
        PRIVATE(this)->usersceneroot->addChild(g);
        this->sceneGraph = g;
      }
    }

    scenecamera->viewAll(this->sceneGraph, this->getViewportRegion());
  }

  this->setCamera(scenecamera);
} // setSceneGraph()

// *************************************************************************

// doc in super
SoNode *
SoGtkViewer::getSceneGraph(void)
{
  // Overloaded from parent class to return the root of the scene
  // graph set by the user, without the extras added by the viewer to
  // control rendering.
  return this->sceneGraph;
} // getSceneGraph()

// *************************************************************************

/*!
  Put the viewer in or out of seek mode.

  If the user performs a mouse button click when the viewer is in seek
  mode, the camera will be repositioned so the camera focal point lies
  on the point of the geometry under the mouse cursor.

  \sa isSeekMode(), setDetailSeek()
*/

void
SoGtkViewer::setSeekMode(SbBool enable)
{
  if (SOGTK_DEBUG) {
    // User might have switched mode during seek, so if enable==FALSE,
    // isViewing() is irrelevant.
    if (enable) { assert(this->isViewing()); }
  }

  if (! enable && PRIVATE(this)->seeksensor->isScheduled()) {
    PRIVATE(this)->seeksensor->unschedule();
    this->interactiveCountDec();
  }

  PRIVATE(this)->inseekmode = enable;
} // setSeekMode()

// *************************************************************************

/*!
  Return a flag which indicates whether or not the viewer is in seek mode.

  \sa setSeekMode()
*/

SbBool
SoGtkViewer::isSeekMode(void) const
{
  return PRIVATE(this)->inseekmode;
} // isSeekMode()

// *************************************************************************

/*!
  Call this method to initiate a seek action towards the 3D intersection
  of the scene and the ray from the screen coordinate's point and in the same
  direction as the camera is pointing.

  Returns \a TRUE if the ray from the \a screenpos position intersect with
  any parts of the onscreen geometry, otherwise FALSE.
*/

SbBool
SoGtkViewer::seekToPoint(const SbVec2s screenpos)
{
  if (! this->camera)
    return FALSE;

  SoRayPickAction rpaction(this->getViewportRegion());
  rpaction.setPoint(screenpos);
  rpaction.setRadius(2);
  rpaction.apply(this->sceneRoot);

  SoPickedPoint * picked = rpaction.getPickedPoint();
  if (!picked) {
    this->interactiveCountInc(); // decremented in setSeekMode(FALSE)
    this->setSeekMode(FALSE);
    return FALSE;
  }

  SbVec3f hitpoint;
  if (PRIVATE(this)->seektopoint) {
    hitpoint = picked->getPoint();
  } 
  else {
    SoGetBoundingBoxAction bbaction(this->getViewportRegion());
    bbaction.apply(picked->getPath());
    SbBox3f bbox = bbaction.getBoundingBox();
    hitpoint = bbox.getCenter();
  }

  PRIVATE(this)->camerastartposition = this->camera->position.getValue();
  PRIVATE(this)->camerastartorient = this->camera->orientation.getValue();

  // move point to the camera coordinate system, consider
  // transformations before camera in the scene graph
  SbMatrix cameramatrix, camerainverse;
  PRIVATE(this)->getCameraCoordinateSystem(this->camera,
                                           this->sceneRoot,
                                           cameramatrix,
                                           camerainverse);
  camerainverse.multVecMatrix(hitpoint, hitpoint);

  float fd = PRIVATE(this)->seekdistance;
  if (!PRIVATE(this)->seekdistanceabs)
    fd *= (hitpoint - this->camera->position.getValue()).length()/100.0f;
  this->camera->focalDistance = fd;

  SbVec3f dir = hitpoint - PRIVATE(this)->camerastartposition;
  dir.normalize();

  // find a rotation that rotates current camera direction into new
  // camera direction.
  SbVec3f olddir;
  this->camera->orientation.getValue().multVec(SbVec3f(0, 0, -1), olddir);
  SbRotation diffrot(olddir, dir);
  PRIVATE(this)->cameraendposition = hitpoint - fd * dir;
  PRIVATE(this)->cameraendorient = this->camera->orientation.getValue() * diffrot;

  if (PRIVATE(this)->seeksensor->isScheduled()) {
    PRIVATE(this)->seeksensor->unschedule();
    this->interactiveCountDec();
  }

  PRIVATE(this)->seeksensor->setBaseTime(SbTime::getTimeOfDay());
  PRIVATE(this)->seeksensor->schedule();
  this->interactiveCountInc();

  return TRUE;
} // seeekToPoint()

// *************************************************************************


void
SoGtkViewerP::reallyRedraw(const SbBool clearcol, const SbBool clearz)
{
  if (this->drawAsHiddenLine()) {

    // First pass: render as filled, but with the background color.

    this->solightmodel->model.setIgnored(FALSE); // override as SoLightModel::BASE
    this->sodrawstyle->style.setIgnored(TRUE); // draw as-is filled/lines/points
    this->socomplexity->type.setIgnored(TRUE); // as-is rendering space
    this->socomplexity->value.setIgnored(TRUE); // as-is complexity on non-simple shapes
    // textureQuality field of socomplexity node is always 0.0

    this->sobasecolor->rgb.setValue(pub->getBackgroundColor());
    this->sobasecolor->rgb.setIgnored(FALSE);
    this->somaterialbinding->value.setIgnored(FALSE); // override with OVERALL
    this->polygonoffsetparent->whichChild = SO_SWITCH_ALL;

    pub->getSceneManager()->render(clearcol, clearz);

    // Second pass, render wireframe on top.

    this->sodrawstyle->style = SoDrawStyle::LINES;
    this->sodrawstyle->style.setIgnored(FALSE); // force lines
    this->sobasecolor->rgb.setIgnored(TRUE); // use as-is line colors
    this->somaterialbinding->value.setIgnored(TRUE); // as-is
    this->polygonoffsetparent->whichChild = SO_SWITCH_NONE;

    pub->getSceneManager()->render(FALSE, FALSE);

    return;
  }
  if (this->drawAsWireframeOverlay()) {
    // First pass: render as-is, with polygon offset

    this->solightmodel->model.setIgnored(TRUE);
    this->somaterialbinding->value.setIgnored(TRUE);
    this->sobasecolor->rgb.setIgnored(TRUE);
    this->sodrawstyle->style.setIgnored(TRUE); // draw as-is filled/lines/points
    this->socomplexity->type.setIgnored(TRUE); // as-is rendering space
    this->socomplexity->value.setIgnored(TRUE); // as-is complexity on non-simple shapes
    this->socomplexity->textureQuality.setIgnored(TRUE);

    this->somaterialbinding->value.setIgnored(TRUE); // override with OVERALL
    this->polygonoffsetparent->whichChild = SO_SWITCH_ALL;

    pub->getSceneManager()->render(clearcol, clearz);

    // Second pass, render wireframe on top.
    this->sobasecolor->rgb.setValue(SbColor(1.0f, 0.0f, 0.0f));
    this->sobasecolor->rgb.setIgnored(FALSE);
    this->somaterialbinding->value.setIgnored(FALSE); // override with OVERALL

    this->solightmodel->model.setIgnored(FALSE); // override as SoLightModel::BASE
    this->sodrawstyle->style = SoDrawStyle::LINES;
    this->sodrawstyle->style.setIgnored(FALSE); // force lines
    this->polygonoffsetparent->whichChild = SO_SWITCH_NONE;
    this->socomplexity->textureQuality.setIgnored(FALSE);

    pub->getSceneManager()->render(FALSE, FALSE);

    SbBool oldnot;

    // disable override nodes
    (void) this->sobasecolor->rgb.enableNotify(FALSE);
    this->sobasecolor->rgb.setIgnored(TRUE);
    (void) this->sobasecolor->rgb.enableNotify(TRUE);

    (void) this->somaterialbinding->value.enableNotify(FALSE);
    this->somaterialbinding->value.setIgnored(TRUE);
    (void) this->somaterialbinding->value.enableNotify(TRUE);

    (void) this->solightmodel->model.enableNotify(FALSE);
    this->solightmodel->model.setIgnored(TRUE);
    (void) this->solightmodel->model.enableNotify(TRUE);

    (void) this->socomplexity->textureQuality.enableNotify(FALSE);
    this->socomplexity->textureQuality.setIgnored(TRUE);
    (void) this->socomplexity->textureQuality.enableNotify(TRUE);

    (void) this->sodrawstyle->style.enableNotify(FALSE);
    this->sodrawstyle->style.setIgnored(TRUE);
    (void) this->sodrawstyle->style.enableNotify(TRUE);
    return;
  }

  SbBool clearzbuffer = TRUE;
  SoGtkViewer::DrawStyle style = this->currentDrawStyle();
  switch (style) {
  case SoGtkViewer::VIEW_LOW_RES_LINE:
  case SoGtkViewer::VIEW_LOW_RES_POINT:
  case SoGtkViewer::VIEW_BBOX:
    clearzbuffer = FALSE;
  default:
    break; // Include "default:" case to avoid compiler warning.
  }

  pub->getSceneManager()->render(clearcol, clearzbuffer && clearz);
}


/*!
  Overloaded from parent class to be able to do the necessary two-pass
  rendering e.g. if the drawing style is \e hidden \e line.
*/

void
SoGtkViewer::actualRedraw(void)
{
  SbTime redrawtime = SbTime::getTimeOfDay();

  // Recalculate near/far planes.
  if (this->isAutoClipping())
    PRIVATE(this)->setClippingPlanes();

  SbBool clearcol = this->isClearBeforeRender();

  if (this->isStereoViewing()) {
    SbColor bgcol = this->getSceneManager()->getBackgroundColor();

    SbBool quadstereo = this->isQuadBufferStereo();
#ifndef HAVE_SOCAMERA_SETSTEREOMODE
    SoCamera * camera = this->getCamera();
    SbVec3f camerapos = camera->position.getValue();
    SbVec3f cameradir(0.0f, 0.0f, -1.0f);
    SbVec3f offsetvec(1.0f, 0.0f, 0.0f);
    float offset = this->getStereoOffset() * 0.5f;
    SbRotation camerarot = camera->orientation.getValue();
    camerarot.multVec(cameradir, cameradir);
    camerarot.multVec(offsetvec, offsetvec);
    SbVec3f focalpoint = camerapos + cameradir * camera->focalDistance.getValue();

    SbBool notifystore = camera->isNotifyEnabled();
    SbBool positionstore = camera->position.isNotifyEnabled();
    SbBool orientationstore = camera->orientation.isNotifyEnabled();
    // turn off notification to avoid redraws
    camera->enableNotify(FALSE);
    camera->position.enableNotify(FALSE);
    camera->orientation.enableNotify(FALSE);

    camera->position = camerapos - offsetvec * offset;
    SbVec3f dir = focalpoint - camera->position.getValue();
    SbRotation rot(cameradir, dir);
    camera->orientation = camerarot * rot;
    if (quadstereo) {
      if (this->isDoubleBuffer())
        glDrawBuffer(GL_BACK_LEFT);
      else
        glDrawBuffer(GL_FRONT_LEFT);
      PRIVATE(this)->reallyRedraw(clearcol);
    }
    else { // red/cyan
      if (this->isDoubleBuffer())
        glDrawBuffer(GL_BACK);
      else
        glDrawBuffer(GL_FRONT);
      glClearColor(bgcol[0], bgcol[1], bgcol[2], 0.0f);
      glClear(GL_DEPTH_BUFFER_BIT|GL_COLOR_BUFFER_BIT);
      glColorMask(1,0,0,1); // draw red-only
      PRIVATE(this)->reallyRedraw(FALSE, FALSE);
    }

    // right eye
    camera->position = camerapos + offsetvec * offset;
    dir = focalpoint - camera->position.getValue();
    rot.setValue(cameradir, dir);
    camera->orientation = camerarot * rot;

    if (quadstereo) {
      if (this->isDoubleBuffer())
        glDrawBuffer(GL_BACK_RIGHT);
      else
        glDrawBuffer(GL_FRONT_RIGHT);
      PRIVATE(this)->reallyRedraw(clearcol);
    }
    else {
      glColorMask(0,1,1,1); // draw green and blue
      PRIVATE(this)->reallyRedraw(FALSE, TRUE);
    }

    // restore camera values and enable notification
    camera->position = camerapos;
    camera->orientation = camerarot;
    camera->position.enableNotify(positionstore);
    camera->orientation.enableNotify(orientationstore);
    camera->enableNotify(notifystore);
    if (quadstereo) {
      if (this->isDoubleBuffer())
        glDrawBuffer(GL_BACK);
      else
        glDrawBuffer(GL_FRONT);
    }
    else {
      glColorMask(1,1,1,1); // restore GL color mask
    }
#else // HAVE_SOCAMERA_SETSTEREOMODE

    if (!quadstereo) {
      SoCamera * camera = this->getCamera();
   if (this->isDoubleBuffer())
    glDrawBuffer(GL_BACK);
   else
    glDrawBuffer(GL_FRONT);
      glClearColor(bgcol[0], bgcol[1], bgcol[2], 0.0f);
      glClear(GL_DEPTH_BUFFER_BIT|GL_COLOR_BUFFER_BIT);
      glColorMask(1,0,0,1); // draw red-only
      camera->setStereoAdjustment(this->getStereoOffset());
      camera->setStereoMode(SoCamera::LEFT_VIEW);
      PRIVATE(this)->reallyRedraw(FALSE, FALSE);

      camera->setStereoMode(SoCamera::RIGHT_VIEW);
      glColorMask(0,1,1,1); // draw green and blue
      PRIVATE(this)->reallyRedraw(FALSE, TRUE);
      camera->setStereoMode(SoCamera::MONOSCOPIC);
      glColorMask(1,1,1,1); // restore GL color mask
    }
    else {
      SoCamera * camera = this->getCamera();
   if (this->isDoubleBuffer())
    glDrawBuffer(GL_BACK_LEFT);
   else
    glDrawBuffer(GL_FRONT_LEFT);
      camera->setStereoAdjustment(this->getStereoOffset());
      camera->setStereoMode(SoCamera::LEFT_VIEW);
      PRIVATE(this)->reallyRedraw(clearcol);
      camera->setStereoMode(SoCamera::RIGHT_VIEW);
   if (this->isDoubleBuffer())
    glDrawBuffer(GL_BACK_RIGHT);
   else
    glDrawBuffer(GL_FRONT_RIGHT);
      PRIVATE(this)->reallyRedraw(clearcol);
      camera->setStereoMode(SoCamera::MONOSCOPIC);
   if (this->isDoubleBuffer())
    glDrawBuffer(GL_BACK);
   else
    glDrawBuffer(GL_FRONT);
    }
#endif // HAVE_SOCAMERA_SETSTEREOMODE
  }
  else PRIVATE(this)->reallyRedraw(clearcol);

  if (PRIVATE(this)->superimpositions != NULL) {
    SoGLRenderAction * raaction = this->getSceneManager()->getGLRenderAction();
    SbBool first = TRUE;
    SbBool zWasEnabled = FALSE;
    for (int i = 0; i < PRIVATE(this)->superimpositions->getLength(); i++) {
      if ((*PRIVATE(this)->superimpositionsenabled)[i] != FALSE) {
	if (first) {
	  // save Z buffer state and disable
          zWasEnabled = glIsEnabled(GL_DEPTH_TEST) ? TRUE : FALSE;
	  glDisable(GL_DEPTH_TEST);
          first = FALSE;
	}
	SoNode * scene = (SoNode *) (*PRIVATE(this)->superimpositions)[i];
	raaction->apply(scene);
      }
    }
    if (!first && zWasEnabled) glEnable(GL_DEPTH_TEST);
  }

  redrawtime = SbTime::getTimeOfDay() - redrawtime;
  PRIVATE(this)->recordFPS(redrawtime.getValue());
}

// *************************************************************************

/*!
  To be able to trigger callback functions when user interaction starts
  and/or stops, we need to keep track of the viewer state (i.e. are we in
  still mode or in animation mode?).

  SoGtkViewer automatically adds callbacks to switch between still and
  moving draw style, and to switch between single/double buffer when
  the buffer type is \a INTERACTIVE.

  \sa interactiveCountDec(), getInteractiveCount()
  \sa addStartCallback(), addFinishCallback()
  \sa removeStartCallback(), removeFinishCallback()
  \sa setDrawStyle(), setBufferingType()
*/

void
SoGtkViewer::interactiveCountInc(void)
{
  // Catch problems with missing interactiveCountDec() calls.
  assert(PRIVATE(this)->interactionnesting < 100);

  if (++(PRIVATE(this)->interactionnesting) == 1)
    PRIVATE(this)->interactionstartCallbacks->invokeCallbacks(this);

#if 0 // debug
  SoDebugError::postInfo("SoGtkViewer::interactiveCountInc", "%d -> %d",
                         PRIVATE(this)->interactionnesting - 1,
                         PRIVATE(this)->interactionnesting);
#endif // debug
} // interactiveCountInc()

// *************************************************************************

/*!
  To be able to trigger callback functions when user interaction starts
  and/or stops, we need to keep track of the viewer state (i.e. are we in
  still mode or in animation mode?).

  SoGtkViewer automatically adds callbacks to switch between still and
  moving draw style, and to switch between single/double buffer when
  the buffer type is \a INTERACTIVE.

  \sa interactiveCountInc(), getInteractiveCount()
  \sa addStartCallback(), addFinishCallback()
  \sa removeStartCallback(), removeFinishCallback()
  \sa setDrawStyle(), setBufferingType()
*/

void
SoGtkViewer::interactiveCountDec(void)
{
  // FIXME: The UI toolkits may cause the interactionnesting to go
  // below zero by triggering press and release events in different
  // widgets. mariusbu 20010709.

  // FIXME: just to clarify; this is due to programming mistakes on
  // our behalf and should be cleaned up. We're using a simple
  // work-around / ignore strategy for now, though, as getting this
  // 100% correct is hard (there are so many possible ways of user
  // interaction with a viewer canvas) and the end-user will usually
  // not notice any problems at all. So that's why we are using a
  // warning instead of an assert(). 20010815 mortene.

  // FIXME: here's one known way to trigger the bug: hit "s" in the
  // examinerviewer in EXAMINE mode, then while seeking hit ESC to put
  // the viewer in INTERACT mode. When the seek is completed, the
  // count will become -1.  20010912 mortene.

  if (SOGTK_DEBUG) {
    if (PRIVATE(this)->interactionnesting <= 0) {
      SoDebugError::postWarning("SoGtkViewer::interactiveCountDec",
                                "interaction count nesting went below zero. "
                                "This is due to an internal SoGtk bug.");
    }
  }

  if (--(PRIVATE(this)->interactionnesting) <= 0) {
    PRIVATE(this)->interactionendCallbacks->invokeCallbacks(this);
    PRIVATE(this)->interactionnesting = 0;
    PRIVATE(this)->resetFrameCounter();
  }
} // interactiveCountDec()

// *************************************************************************

/*!
  Return current interaction count nesting. If equal to zero, the viewer
  is in animation mode, otherwise the camera is still.

  \sa interactiveCountInc(), interactiveCountDec()
*/

int
SoGtkViewer::getInteractiveCount(void) const
{
  return PRIVATE(this)->interactionnesting;
} // getInteractiveCount()

// *************************************************************************

/*!
  Set the value used for calculating how close the camera and intersection
  hit point should be made at the end of a seek operation.

  The value can be interpreted as an absolute value in the given world
  unit (which typically is meters) or as a percentage value of the
  distance between the camera starting position and the intersection
  hit point. This can be controlled through the
  setSeekValueAsPercentage() method. It is as default used as an
  absolute value.

  Default value is 50 (absolute distance or percent).

  \sa getSeekDistance(), setSeekValueAsPercentage(), setSeekTime()
*/

void
SoGtkViewer::setSeekDistance(const float distance)
{
  if (distance <= 0.0f) {
    if (SOGTK_DEBUG) {
      SoDebugError::postWarning("SoGtkViewer::setSeekDistance",
                                "invalid seek distance value: %f",
                                distance);
    }
    return;
  }
  PRIVATE(this)->seekdistance = distance;
} // setSeekDistance()

// *************************************************************************

/*!
  Returns the current seek distance. Value given as an absolute scalar
  length or as a percentage value of the original distance between
  the hitpoint and the camera starting position.

  \sa setSeekDistance(), isSeekValueAsPercentage()
*/

float
SoGtkViewer::getSeekDistance(void) const
{
  return PRIVATE(this)->seekdistance;
} // getSeekDistance()

// *************************************************************************

/*!
  Control whether or not the seek distance value should be interpreted as
  a percentage value or as an absolute distance. See documentation on
  setSeekDistance() for more information.

  \sa setSeekDistance(), isSeekValueAsPercentage()
*/

void
SoGtkViewer::setSeekValueAsPercentage(const SbBool on)
{
  if (SOGTK_DEBUG) {
    if ((on && this->isSeekValuePercentage()) ||
        (!on && !this->isSeekValuePercentage())) {
      SoDebugError::postWarning("SoGtkViewer::setSeekDistanceAsPercentage",
                                "unnecessary called, value already %s",
                                on ? "on" : "off");
      return;
    }
  }

  PRIVATE(this)->seekdistanceabs = on ? FALSE : TRUE;
} // setSeekValkueAsPercentage()

// *************************************************************************

/*!
  Returns an boolean which indicates if the seek distance value from
  getSeekDistance() should be interpreted as a percentage value or
  as an absolute value.

  \sa setSeekValuePercentage(), getSeekDistance()
*/

SbBool
SoGtkViewer::isSeekValuePercentage(void) const
{
  return PRIVATE(this)->seekdistanceabs ? FALSE : TRUE;
} // isSeekValuePercentage()

// ************************************************************************

/*!
  This method is obsoleted in Coin SoGtk.
 */
void
SoGtkViewer::computeSeekFinalOrientation(void)
{
  SOGTK_OBSOLETED();
}

// *************************************************************************

/*!
  If the current camera is of perspective type, switch to
  orthographic, and vice versa.

  Automatically calls SoGtkViewer::setCameraType() so the change
  will immediately take place.
*/
void
SoGtkViewer::toggleCameraType(void)
{
  SoType perspectivetype = SoPerspectiveCamera::getClassTypeId();
  SoType orthotype = SoOrthographicCamera::getClassTypeId();

  this->setCameraType(PRIVATE(this)->cameratype.isDerivedFrom(perspectivetype)
                       ? orthotype : perspectivetype);
} // toggleCameraType()

// ************************************************************************

/*!
  Copies the settings of \a camera into our current camera.  Cameras
  must be of the same class type.
 */
void
SoGtkViewer::changeCameraValues(// virtual, protected
  SoCamera * camera)
{
  assert(camera != NULL);

  SoCamera * cam = this->getCamera();
  if (!cam) {
    if (SOGTK_DEBUG) {
      SoDebugError::postWarning("SoGtkViewer::changeCameraValues",
                                "no current camera in the scenegraph");
    }
    return;
  }
  if (cam->getTypeId() != camera->getTypeId()) {
    if (SOGTK_DEBUG) {
      SoDebugError::postWarning("SoGtkViewer::changeCameraValues",
                                "tried to copy data from camera of "
                                "different type");
    }
    return;
  }

  cam->copyFieldValues(camera, FALSE);
}

// *************************************************************************

/*!
  \internal

  Returns a boolean to indicate if the dynamic drawstyle equals
  the static drawstyle.
*/

SbBool
SoGtkViewerP::drawInteractiveAsStill(void) const
{
  SbBool moveasstill = this->drawstyles[SoGtkViewer::INTERACTIVE] == SoGtkViewer::VIEW_SAME_AS_STILL;
  if (! moveasstill)
    moveasstill = this->drawstyles[SoGtkViewer::INTERACTIVE] == this->drawstyles[SoGtkViewer::STILL];
  if (! moveasstill)
    moveasstill =
      this->drawstyles[SoGtkViewer::INTERACTIVE] == SoGtkViewer::VIEW_NO_TEXTURE &&
      this->drawstyles[SoGtkViewer::STILL] != SoGtkViewer::VIEW_AS_IS;
  return moveasstill;
} // drawInteractiveAsStill()

// *************************************************************************

/*!
  \internal

  Returns the current drawing style.
*/

SoGtkViewer::DrawStyle
SoGtkViewerP::currentDrawStyle(
  void) const
{
  SbBool interactivemode = pub->getInteractiveCount() > 0 ? TRUE : FALSE;

  if (!interactivemode || this->drawInteractiveAsStill())
    return this->drawstyles[SoGtkViewer::STILL];
  else
    return this->drawstyles[SoGtkViewer::INTERACTIVE];
} // currentDrawStyle()

// *************************************************************************

/*!
  \internal

  Returns a boolean to indicate if the current drawstyle settings implies
  hidden line rendering.
*/

SbBool
SoGtkViewerP::drawAsHiddenLine(void) const
{
  return ((this->currentDrawStyle() == SoGtkViewer::VIEW_HIDDEN_LINE) ? TRUE : FALSE);
} // drawAsHiddenLine()

/*!
  \internal

  Returns a boolean to indicate if the current drawstyle settings implies
  wirefram overlay rendering.
*/

SbBool
SoGtkViewerP::drawAsWireframeOverlay(void) const
{
  return ((this->currentDrawStyle() == SoGtkViewer::VIEW_WIREFRAME_OVERLAY) ? TRUE : FALSE);
} // drawAsWireframeOverlay()


// *************************************************************************

/*!
  \internal

  Use the given style setting to set the correct states in the
  rendering control nodes. This will affect the way the scene is
  currently rendered.
*/

void
SoGtkViewerP::changeDrawStyle(SoGtkViewer::DrawStyle style)
{
  // Turn on/off Z-buffering based on the style setting.
  switch (style) {
  case SoGtkViewer::VIEW_LOW_RES_LINE:
  case SoGtkViewer::VIEW_LOW_RES_POINT:
  case SoGtkViewer::VIEW_BBOX:
    pub->glLockNormal();
    // FIXME: shouldn't this be done "lazy", i.e. before we do any
    // actual rendering? 20001126 mortene.
    glDisable(GL_DEPTH_TEST);
    pub->glUnlockNormal();
    break;

  default:
    pub->glLockNormal();
    // FIXME: shouldn't this be done "lazy", i.e. before we do any
    // actual rendering? 20001126 mortene.
    glEnable(GL_DEPTH_TEST);
    pub->glUnlockNormal();
    break;
  }

  // Render everything as its supposed to be done, don't override
  // any of the settings in the ``real'' graph.
  if (style == SoGtkViewer::VIEW_AS_IS) {
    this->drawstyleroot->whichChild = SO_SWITCH_NONE;
    return;
  }

  this->drawstyleroot->whichChild = SO_SWITCH_ALL;
  if ((style == SoGtkViewer::VIEW_HIDDEN_LINE) ||
      (style == SoGtkViewer::VIEW_WIREFRAME_OVERLAY)) {
    this->hiddenlineroot->whichChild = SO_SWITCH_ALL;
    return;
  } else {
    this->hiddenlineroot->whichChild = SO_SWITCH_NONE;
  }

  // Set or unset lightmodel override.
  switch (style) {
  case SoGtkViewer::VIEW_NO_TEXTURE:
  case SoGtkViewer::VIEW_LOW_COMPLEXITY:
    this->solightmodel->model.setIgnored(TRUE); // as-is BASE or PHONG
    break;

  case SoGtkViewer::VIEW_LINE:
  case SoGtkViewer::VIEW_POINT:
  case SoGtkViewer::VIEW_BBOX:
  case SoGtkViewer::VIEW_LOW_RES_LINE:
  case SoGtkViewer::VIEW_LOW_RES_POINT:
    this->solightmodel->model.setIgnored(FALSE); // force BASE lighting
    break;

  default:
    assert(FALSE); break;
  }


  // Set or unset drawstyle override.
  switch (style) {
  case SoGtkViewer::VIEW_NO_TEXTURE:
  case SoGtkViewer::VIEW_LOW_COMPLEXITY:
    this->sodrawstyle->style.setIgnored(TRUE); // as-is drawing style filled/lines/points
    break;

  case SoGtkViewer::VIEW_LINE:
  case SoGtkViewer::VIEW_LOW_RES_LINE:
  case SoGtkViewer::VIEW_BBOX:
    this->sodrawstyle->style = SoDrawStyle::LINES;
    this->sodrawstyle->style.setIgnored(FALSE); // force line rendering
    break;

  case SoGtkViewer::VIEW_POINT:
  case SoGtkViewer::VIEW_LOW_RES_POINT:
    this->sodrawstyle->style = SoDrawStyle::POINTS;
    this->sodrawstyle->style.setIgnored(FALSE); // force point rendering
    break;

  default:
    assert(FALSE); break;
  }

  // Set or unset complexity value override.
  switch (style) {
  case SoGtkViewer::VIEW_NO_TEXTURE:
  case SoGtkViewer::VIEW_LINE:
  case SoGtkViewer::VIEW_POINT:
  case SoGtkViewer::VIEW_BBOX:
    this->socomplexity->value.setIgnored(TRUE); // as-is complexity
    break;

  case SoGtkViewer::VIEW_LOW_COMPLEXITY:
  case SoGtkViewer::VIEW_LOW_RES_LINE:
  case SoGtkViewer::VIEW_LOW_RES_POINT:
    this->socomplexity->value.setIgnored(FALSE); // force complexity setting of 0.1
    break;

  default:
    assert(FALSE); break;
  }

  // Set or unset complexity type override.
  switch (style) {
  case SoGtkViewer::VIEW_NO_TEXTURE:
  case SoGtkViewer::VIEW_LOW_COMPLEXITY:
  case SoGtkViewer::VIEW_LINE:
  case SoGtkViewer::VIEW_POINT:
  case SoGtkViewer::VIEW_LOW_RES_LINE:
  case SoGtkViewer::VIEW_LOW_RES_POINT:
    this->socomplexity->type.setIgnored(TRUE); // as-is
    break;

  case SoGtkViewer::VIEW_BBOX:
    this->socomplexity->type = SoComplexity::BOUNDING_BOX;
    this->socomplexity->type.setIgnored(FALSE); // force bounding box rendering
    break;

  default:
    assert(FALSE); break;
  }

#if 0 // debug
  SoDebugError::postInfo("SoGtkViewer::changeDrawStyle",
                         "\n"
                         "\tdrawstyle style: 0x%02x (isIgnored() == %s)\n"
                         "\tlightmodel model: 0x%02x, (isIgnored() == %s)\n"
                         "\tcomplexity type: 0x%02x, (isIgnored() == %s)\n"
                         "\tcomplexity value: %f, (isIgnored() == %s)\n"
                         "",
                         this->sodrawstyle->style.getValue(),
                         this->sodrawstyle->style.isIgnored() ? "T" : "F",
                         this->solightmodel->model.getValue(),
                         this->solightmodel->model.isIgnored() ? "T" : "F",
                         this->socomplexity->type.getValue(),
                         this->socomplexity->type.isIgnored() ? "T" : "F",
                         this->socomplexity->value.getValue(),
                         this->socomplexity->value.isIgnored() ? "T" : "F");
#endif // debug
}

// *************************************************************************

/*!
  \internal

  Position the near and far clipping planes just in front of and behind
  the scene's bounding box. This will give us the optimal utilization of
  the z buffer resolution by shrinking it to its minimum depth.

  Near and far clipping planes are specified in the camera fields
  nearDistance and farDistance.
*/
void
SoGtkViewerP::setClippingPlanes(void)
{
  // This is necessary to avoid a crash in case there is no scene
  // graph specified by the user.
  if (pub->camera == NULL) return;

  if (pub->autoClipBboxAction == NULL)
    pub->autoClipBboxAction =
      new SoGetBoundingBoxAction(pub->getViewportRegion());
  else
    pub->autoClipBboxAction->setViewportRegion(pub->getViewportRegion());

  pub->autoClipBboxAction->apply(pub->sceneRoot);

  SbXfBox3f xbox = pub->autoClipBboxAction->getXfBoundingBox();

  SbMatrix cammat;
  SbMatrix inverse;
  this->getCameraCoordinateSystem(pub->camera, pub->sceneRoot, cammat, inverse);
  xbox.transform(inverse);

  SbMatrix mat;
  mat.setTranslate(- pub->camera->position.getValue());
  xbox.transform(mat);
  mat = pub->camera->orientation.getValue().inverse();
  xbox.transform(mat);
  SbBox3f box = xbox.project();

  // Bounding box was calculated in camera space, so we need to "flip"
  // the box (because camera is pointing in the (0,0,-1) direction
  // from origo.
  float nearval = -box.getMax()[2];
  float farval = -box.getMin()[2];

  // FIXME: what if we have a weird scale transform in the scenegraph?
  // Could we end up with nearval > farval then? Investigate, then
  // either use an assert() (if it can't happen) or an SoGtkSwap()
  // (to handle it). 20020116 mortene.

  // Check if scene is completely behind us.
  if (farval <= 0.0f) { return; }

  if (pub->camera->isOfType(SoPerspectiveCamera::getClassTypeId())) {
    // Disallow negative near clipping plane distance.
    if (nearval <= 0.0f) {
      // Set to a short distance, but make sure we're still well below
      // the far clipping plane distance (in case that is also very
      // short).
      nearval = SoGtkMin(0.1f, farval / 5000.0f);
      // (The "5000" magic constant was found by fiddling around a bit
      // on an OpenGL implementation with a 16-bit depth-buffer
      // resolution, adjusting to find something that would work well
      // with both a very "stretched" / deep scene and a more compact
      // single-model one.)
    }
  }

  // Some slack around the bounding box, in case the scene fits
  // exactly inside it. This is done to minimize the chance of
  // artifacts caused by the limitation of the z-buffer
  // resolution. One common artifact if this is not done is that the
  // near clipping plane cuts into the corners of the model as it's
  // rotated.
  const float SLACK = 0.001f;

  pub->camera->nearDistance = nearval * (1.0f - SLACK);
  pub->camera->farDistance = farval * (1.0f + SLACK);


  // FIXME: there's a possible optimization to take advantage of here,
  // since we are able to sometimes know for sure that all geometry is
  // completely inside the view volume. I quote from the "OpenGL FAQ
  // and Troubleshooting Guide":
  //
  //  "10.050 I know my geometry is inside the view volume. How can I
  //  turn off OpenGL's view-volume clipping to maximize performance?
  //
  //   Standard OpenGL doesn't provide a mechanism to disable the
  //   view-volume clipping test; thus, it will occur for every
  //   primitive you send.
  //
  //   Some implementations of OpenGL support the
  //   GL_EXT_clip_volume_hint extension. If the extension is
  //   available, a call to
  //   glHint(GL_CLIP_VOLUME_CLIPPING_HINT_EXT,GL_FASTEST) will inform
  //   OpenGL that the geometry is entirely within the view volume and
  //   that view-volume clipping is unnecessary. Normal clipping can
  //   be resumed by setting this hint to GL_DONT_CARE. When clipping
  //   is disabled with this hint, results are undefined if geometry
  //   actually falls outside the view volume."
  //
  // 20020117 mortene.


  if (SOGTK_DEBUG && 0) { // debug
    SoDebugError::postInfo("SoGtkViewer::setClippingPlanes",
                           "near, far: %f (%f), %f (%f)",
                           nearval, pub->camera->nearDistance.getValue(),
                           farval, pub->camera->farDistance.getValue());
  }
}

// *************************************************************************

/*!
  \internal

  Translate camera a distance equal to the difference in projected,
  normalized screen coordinates given by the argument.
*/

void
SoGtkViewerP::moveCameraScreen(const SbVec2f & screenpos)
{
  SoCamera * cam = pub->getCamera();
  assert(cam);

  if (SOGTK_DEBUG && 0) { // debug
    SoDebugError::postInfo("SoGtkViewer::moveCameraScreen",
                           "screenpos: <%f, %f>, campos: <%f, %f, %f>",
                           screenpos[0], screenpos[1],
                           cam->position.getValue()[0],
                           cam->position.getValue()[1],
                           cam->position.getValue()[2]);
  }

  SbViewVolume vv = cam->getViewVolume(pub->getGLAspectRatio());
  SbPlane panplane = vv.getPlane(cam->focalDistance.getValue());

  SbLine line;
  vv.projectPointToLine(screenpos + SbVec2f(0.5, 0.5f), line);
  SbVec3f current_planept;
  panplane.intersect(line, current_planept);
  vv.projectPointToLine(SbVec2f(0.5f, 0.5f), line);
  SbVec3f old_planept;
  panplane.intersect(line, old_planept);

  // Reposition camera according to the vector difference between the
  // projected points.
  cam->position = cam->position.getValue() - (current_planept - old_planept);

  if (SOGTK_DEBUG && 0) { // debug
    SoDebugError::postInfo("SoGtkViewer::moveCameraScreen",
                           "newcampos: <%f, %f, %f>",
                           cam->position.getValue()[0],
                           cam->position.getValue()[1],
                           cam->position.getValue()[2]);
  }
}

// *************************************************************************

/*!
  \internal

  Called when viewer enters interactive mode (animation, drag, ...).
*/
void
SoGtkViewerP::interactivestartCB(void *, SoGtkViewer * thisp)
{
  // In interactive buffer mode, doublebuffering is used during interaction.
  if (PRIVATE(thisp)->buffertype == SoGtkViewer::BUFFER_INTERACTIVE) {
    PRIVATE(thisp)->localsetbuffertype = TRUE;
    thisp->SoGtkRenderArea::setDoubleBuffer(TRUE);
    PRIVATE(thisp)->localsetbuffertype = FALSE;
  }

  // Use the dynamic drawstyle.
  if (!PRIVATE(thisp)->drawInteractiveAsStill())
    PRIVATE(thisp)->changeDrawStyle(PRIVATE(thisp)->drawstyles[SoGtkViewer::INTERACTIVE]);
}

/*!
  \internal

  Called when viewer goes out of interactive mode and into
  "frozen" mode.
*/
void
SoGtkViewerP::interactiveendCB(void *, SoGtkViewer * thisp)
{
  // In interactive buffer mode, doublebuffering is used during
  // interaction, singelbuffering while the camera is static.
  if (PRIVATE(thisp)->buffertype == SoGtkViewer::BUFFER_INTERACTIVE) {
    PRIVATE(thisp)->localsetbuffertype = TRUE;
    thisp->SoGtkRenderArea::setDoubleBuffer(FALSE);
    PRIVATE(thisp)->localsetbuffertype = FALSE;
  }

  // Back to static drawstyle.
  if (!PRIVATE(thisp)->drawInteractiveAsStill())
    PRIVATE(thisp)->changeDrawStyle(PRIVATE(thisp)->drawstyles[SoGtkViewer::STILL]);
}

// *************************************************************************

/*!
  \internal

  Called repeatedly during the seek animation.
*/
void
SoGtkViewerP::seeksensorCB(void * data, SoSensor * s)
{
  SbTime currenttime = SbTime::getTimeOfDay();

  SoGtkViewer * thisp = (SoGtkViewer *)data;
  SoTimerSensor * sensor = (SoTimerSensor *)s;

  float t =
    (currenttime - sensor->getBaseTime()).getValue() / PRIVATE(thisp)->seekperiod;
  if ((t > 1.0f) || (t + sensor->getInterval().getValue() > 1.0f)) t = 1.0f;
  SbBool end = (t == 1.0f);
  
  t = (float) ((1.0 - cos(M_PI*t)) * 0.5);
  
  thisp->camera->position = PRIVATE(thisp)->camerastartposition +
    (PRIVATE(thisp)->cameraendposition - PRIVATE(thisp)->camerastartposition) * t;
  thisp->camera->orientation = 
    SbRotation::slerp(PRIVATE(thisp)->camerastartorient,
                      PRIVATE(thisp)->cameraendorient, 
                      t);

  if (end) thisp->setSeekMode(FALSE);
}

// *************************************************************************

// doc in super
void
SoGtkViewer::sizeChanged(const SbVec2s & size)
{
  inherited::sizeChanged(size);
}

// *************************************************************************

/*!
  Reset the frames-per-second counter upon window resize events,
  abnormal delays, etc.

  The methods for recording FPS values are Coin extensions, not
  available in the original Open Inventor API.

  \sa addFrametime(), recordFPS()
*/
void
SoGtkViewerP::resetFrameCounter(void)
{
  this->framecount = 0;
  for (int i = 0; i < SoGtkViewerP::FRAMESARRAY_SIZE; i++)
    this->frames[i] = 0.0;
  this->totalval = 0.0;
  this->currentframetime = 0.0;
}

/*!
  Adds the time spent drawing the last frame to the array of past
  frame times.

  The methods for recording FPS values are Coin extensions, not
  available in the original Open Inventor API.

  \sa resetFrameCounter(), recordFPS()
*/

void
SoGtkViewerP::addFrametime(const double ft)
{
  this->framecount++;

  int arrayptr = (this->framecount - 1) % FRAMESARRAY_SIZE;
  double oldval = this->frames[arrayptr];
  this->frames[arrayptr] = ft;
  this->totalval += (ft - oldval);
  this->currentframetime =
    this->totalval / SoGtkMin(this->framecount, (int) FRAMESARRAY_SIZE);
}

static unsigned char fps2dfont[][12] = {
  {  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 }, //
  {  0,  0, 12, 12,  0,  8, 12, 12, 12, 12, 12,  0 }, // !
  {  0,  0,  0,  0,  0,  0,  0,  0,  0, 20, 20, 20 }, // \"
  {  0,  0, 18, 18, 18, 63, 18, 18, 63, 18, 18,  0 }, // #
  {  0,  8, 28, 42, 10, 10, 12, 24, 40, 42, 28,  8 }, // $
  {  0,  0,  6, 73, 41, 22,  8, 52, 74, 73, 48,  0 }, // %
  {  0, 12, 18, 18, 12, 25, 37, 34, 34, 29,  0,  0 }, // &
  { 12, 12, 24,  0,  0,  0,  0,  0,  0,  0,  0,  0 }, // '
  {  0,  6,  8,  8, 16, 16, 16, 16, 16,  8,  8,  6 }, // (
  {  0, 48,  8,  8,  4,  4,  4,  4,  4,  8,  8, 48 }, //)
  {  0,  0,  0,  0,  0,  0,  8, 42, 20, 42,  8,  0 }, // *
  {  0,  0,  0,  8,  8,  8,127,  8,  8,  8,  0,  0 }, // +
  {  0, 24, 12, 12,  0,  0,  0,  0,  0,  0,  0,  0 }, // ,
  {  0,  0,  0,  0,  0,  0,127,  0,  0,  0,  0,  0 }, // -
  {  0,  0, 24, 24,  0,  0,  0,  0,  0,  0,  0,  0 }, // .
  {  0, 32, 32, 16, 16,  8,  8,  8,  4,  4,  2,  2 }, // /
  {  0,  0, 28, 34, 34, 34, 34, 34, 34, 34, 28,  0 }, // 0
  {  0,  0,  8,  8,  8,  8,  8,  8, 40, 24,  8,  0 }, // 1
  {  0,  0, 62, 32, 16,  8,  4,  2,  2, 34, 28,  0 }, // 2
  {  0,  0, 28, 34,  2,  2, 12,  2,  2, 34, 28,  0 }, // 3
  {  0,  0,  4,  4,  4,126, 68, 36, 20, 12,  4,  0 }, // 4
  {  0,  0, 28, 34,  2,  2,  2, 60, 32, 32, 62,  0 }, // 5
  {  0,  0, 28, 34, 34, 34, 60, 32, 32, 34, 28,  0 }, // 6
  {  0,  0, 16, 16, 16,  8,  8,  4,  2,  2, 62,  0 }, // 7
  {  0,  0, 28, 34, 34, 34, 28, 34, 34, 34, 28,  0 }, // 8
  {  0,  0, 28, 34,  2,  2, 30, 34, 34, 34, 28,  0 }, // 9
  {  0,  0, 24, 24,  0,  0,  0, 24, 24,  0,  0,  0 }, // :
  {  0, 48, 24, 24,  0,  0,  0, 24, 24,  0,  0,  0 }, // ;
  {  0,  0,  0,  2,  4,  8, 16,  8,  4,  2,  0,  0 }, // <
  {  0,  0,  0,  0,  0,127,  0,127,  0,  0,  0,  0 }, // =
  {  0,  0,  0, 16,  8,  4,  2,  4,  8, 16,  0,  0 }, // >
  {  0,  0, 16, 16,  0, 16, 28,  2,  2,  2, 60,  0 }, // ?
  {  0,  0, 28, 32, 73, 86, 82, 82, 78, 34, 28,  0 }, // @
  {  0,  0, 33, 33, 33, 63, 18, 18, 18, 12, 12,  0 }, // A
  {  0,  0, 60, 34, 34, 34, 60, 34, 34, 34, 60,  0 }, // B
  {  0,  0, 14, 16, 32, 32, 32, 32, 32, 18, 14,  0 }, // C
  {  0,  0, 56, 36, 34, 34, 34, 34, 34, 36, 56,  0 }, // D
  {  0,  0, 62, 32, 32, 32, 60, 32, 32, 32, 62,  0 }, // E
  {  0,  0, 16, 16, 16, 16, 30, 16, 16, 16, 30,  0 }, // F
  {  0,  0, 14, 18, 34, 34, 32, 32, 32, 18, 14,  0 }, // G
  {  0,  0, 34, 34, 34, 34, 62, 34, 34, 34, 34,  0 }, // H
  {  0,  0, 62,  8,  8,  8,  8,  8,  8,  8, 62,  0 }, // I
  {  0,  0,112,  8,  8,  8,  8,  8,  8,  8, 62,  0 }, // J
  {  0,  0, 33, 33, 34, 36, 56, 40, 36, 34, 33,  0 }, // K
  {  0,  0, 30, 16, 16, 16, 16, 16, 16, 16, 16,  0 }, // L
  {  0,  0, 33, 33, 33, 45, 45, 45, 51, 51, 33,  0 }, // M
  {  0,  0, 34, 34, 38, 38, 42, 42, 50, 50, 34,  0 }, // N
  {  0,  0, 12, 18, 33, 33, 33, 33, 33, 18, 12,  0 }, // O
  {  0,  0, 32, 32, 32, 60, 34, 34, 34, 34, 60,  0 }, // P
  {  3,  6, 12, 18, 33, 33, 33, 33, 33, 18, 12,  0 }, // Q
  {  0,  0, 34, 34, 34, 36, 60, 34, 34, 34, 60,  0 }, // R
  {  0,  0, 60,  2,  2,  6, 28, 48, 32, 32, 30,  0 }, // S
  {  0,  0,  8,  8,  8,  8,  8,  8,  8,  8,127,  0 }, // T
  {  0,  0, 28, 34, 34, 34, 34, 34, 34, 34, 34,  0 }, // U
  {  0,  0, 12, 12, 18, 18, 18, 33, 33, 33, 33,  0 }, // V
  {  0,  0, 34, 34, 34, 54, 85, 73, 73, 73, 65,  0 }, // W
  {  0,  0, 34, 34, 20, 20,  8, 20, 20, 34, 34,  0 }, // X
  {  0,  0,  8,  8,  8,  8, 20, 20, 34, 34, 34,  0 }, // Y
  {  0,  0, 62, 32, 16, 16,  8,  4,  4,  2, 62,  0 }, // Z
  {  0, 14,  8,  8,  8,  8,  8,  8,  8,  8,  8, 14 }, // [
  {  0,  2,  2,  4,  4,  8,  8,  8, 16, 16, 32, 32 }, // [backslash]
  {  0, 56,  8,  8,  8,  8,  8,  8,  8,  8,  8, 56 }, // ]
  {  0,  0,  0,  0,  0, 34, 34, 20, 20,  8,  8,  0 }, // ^
  {  0,127,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 }, // _
  {  0,  0,  0,  0,  0,  0,  0,  0,  0, 24, 24, 12 }, // `
  {  0,  0, 29, 34, 34, 30,  2, 34, 28,  0,  0,  0 }, // a
  {  0,  0, 60, 34, 34, 34, 34, 50, 44, 32, 32, 32 }, // b
  {  0,  0, 14, 16, 32, 32, 32, 16, 14,  0,  0,  0 }, // c
  {  0,  0, 26, 38, 34, 34, 34, 34, 30,  2,  2,  2 }, // d
  {  0,  0, 28, 34, 32, 62, 34, 34, 28,  0,  0,  0 }, // e
  {  0,  0, 16, 16, 16, 16, 16, 16, 62, 16, 16, 14 }, // f
  { 28,  2,  2, 26, 38, 34, 34, 34, 30,  0,  0,  0 }, // g
  {  0,  0, 34, 34, 34, 34, 34, 50, 44, 32, 32, 32 }, // h
  {  0,  0,  8,  8,  8,  8,  8,  8, 56,  0,  8,  8 }, // i
  { 56,  4,  4,  4,  4,  4,  4,  4, 60,  0,  4,  4 }, // j
  {  0,  0, 33, 34, 36, 56, 40, 36, 34, 32, 32, 32 }, // k
  {  0,  0,  8,  8,  8,  8,  8,  8,  8,  8,  8, 56 }, // l
  {  0,  0, 73, 73, 73, 73, 73,109, 82,  0,  0,  0 }, // m
  {  0,  0, 34, 34, 34, 34, 34, 50, 44,  0,  0,  0 }, // n
  {  0,  0, 28, 34, 34, 34, 34, 34, 28,  0,  0,  0 }, // o
  { 32, 32, 60, 34, 34, 34, 34, 50, 44,  0,  0,  0 }, // p
  {  2,  2, 26, 38, 34, 34, 34, 34, 30,  0,  0,  0 }, // q
  {  0,  0, 16, 16, 16, 16, 16, 24, 22,  0,  0,  0 }, // r
  {  0,  0, 60,  2,  2, 28, 32, 32, 30,  0,  0,  0 }, // s
  {  0,  0, 14, 16, 16, 16, 16, 16, 62, 16, 16,  0 }, // t
  {  0,  0, 26, 38, 34, 34, 34, 34, 34,  0,  0,  0 }, // u
  {  0,  0,  8,  8, 20, 20, 34, 34, 34,  0,  0,  0 }, // v
  {  0,  0, 34, 34, 34, 85, 73, 73, 65,  0,  0,  0 }, // w
  {  0,  0, 34, 34, 20,  8, 20, 34, 34,  0,  0,  0 }, // x
  { 48, 16,  8,  8, 20, 20, 34, 34, 34,  0,  0,  0 }, // y
  {  0,  0, 62, 32, 16,  8,  4,  2, 62,  0,  0,  0 }, // z
  {  0,  6,  8,  8,  8,  4, 24,  4,  8,  8,  8,  6 }, // {
  {  0,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8 }, // |
  {  0, 48,  8,  8,  8, 16, 12, 16,  8,  8,  8, 48 }, // }
  {  0,  0,  0,  0,  0,  0, 78, 57,  0,  0,  0,  0 }  // ~
};

static void
printString(const char * s)
{
#if defined(__COIN__)
  int i,n;
  n = strlen(s);
  for (i = 0; i < n; i++)
    glBitmap(8, 12, 0.0, 2.0, 10.0, 0.0, fps2dfont[s[i] - 32]);
#endif
}

static void
Draw2DString(const char * str, SbVec2s glsize, SbVec2f position)
{
  // Store GL state.
  glPushAttrib(GL_ALL_ATTRIB_BITS);

  glDisable(GL_LIGHTING);
  glDisable(GL_DEPTH_TEST);
  glDisable(GL_TEXTURE_2D);
  glMatrixMode(GL_MODELVIEW);
  glPushMatrix();
  glLoadIdentity();

  glMatrixMode(GL_PROJECTION);
  glPushMatrix();
  glLoadIdentity();
  glOrtho(0.0, glsize[0], 0.0, glsize[1], -1, 1);

  glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

  glColor3f(0.0, 0.0, 0.0);
  glRasterPos2f(position[0] + 1, position[1]);
  printString(str);
  glRasterPos2f(position[0] - 1, position[1]);
  printString(str);
  glRasterPos2f(position[0], position[1] + 1);
  printString(str);
  glRasterPos2f(position[0], position[1] - 1);
  printString(str);

  glColor3f(1.0, 1.0, 0.0);
  glRasterPos2f(position[0], position[1]);
  printString(str);

  glMatrixMode(GL_PROJECTION);
  glPopMatrix();
  glMatrixMode(GL_MODELVIEW);
  glPopMatrix();

  glPopAttrib();
}


// FIXME: the following is just a temporary hack to enable the FPS
// counter. We should really write a proper interface against it, so
// applications can set up feedback loops to control scene complexity
// and get a nice and steady maximum framerate, for instance.
//
// For anyone who want to execute that task, check what TGS has done
// first. If their API is fine, use the same approach.
//
// 20001124 mortene.

/*!
  Draw a text string showing the current frame-per-seconds value in
  the lower left corner of the OpenGL canvas (after recording
  information needed to calculate the fps).

  The methods for recording FPS values are Coin extensions, not
  available in the original Open Inventor API.

  \sa resetFrameCounter(), addFrametime()
*/
void
SoGtkViewerP::recordFPS(const double rendertime)
{
  if (COIN_SHOW_FPS_COUNTER == UNINITIALIZED_ENVVAR) {
    const char * env = SoAny::si()->getenv("COIN_SHOW_FPS_COUNTER");
    COIN_SHOW_FPS_COUNTER = env ? atoi(env) : 0;
  }

  if (COIN_SHOW_FPS_COUNTER) {
    this->addFrametime(rendertime);

    char buffer[64];
    int nr = sprintf(buffer, "%.1f fps", 1.0 / this->currentframetime);
    assert(nr < 64);
    Draw2DString(buffer, pub->getGLSize(), SbVec2f(10, 10));
  }
}

// *************************************************************************

// Documented in superclass.
SbBool
SoGtkViewer::processSoEvent(const SoEvent * const event)
{
  const SoType type(event->getTypeId());
  const SoKeyboardEvent * keyevent = NULL;

  if (type.isDerivedFrom(SoKeyboardEvent::getClassTypeId())) {
    keyevent = (SoKeyboardEvent *) event;
    // the ESC key switches between view and interact mode
    if (keyevent->getKey() == SoKeyboardEvent::ESCAPE &&
        keyevent->getState() == SoButtonEvent::DOWN) {
      this->setViewing(this->isViewing() ? FALSE : TRUE);
      return TRUE;
    }
  }

  // If not viewing, break off further handling and pass the event on
  // to the SoGtkRenderArea, which will pass it on to the
  // scenegraph.
  if (!this->isViewing()) { return inherited::processSoEvent(event); }


  if (keyevent && (keyevent->getState() == SoButtonEvent::DOWN)) {
    switch (keyevent->getKey()) {
    case SoKeyboardEvent::S:
      this->setSeekMode(this->isSeekMode() ? FALSE : TRUE);
      return TRUE;
    case SoKeyboardEvent::Q:
      this->hide();
      SoGtk::exitMainLoop();
      return TRUE;
    case SoKeyboardEvent::HOME:
      this->resetToHomePosition();
      return TRUE;
    case SoKeyboardEvent::LEFT_ARROW:
      PRIVATE(this)->moveCameraScreen(SbVec2f(-0.1f, 0.0f));
      return TRUE;
    case SoKeyboardEvent::UP_ARROW:
      PRIVATE(this)->moveCameraScreen(SbVec2f(0.0f, 0.1f));
      return TRUE;
    case SoKeyboardEvent::RIGHT_ARROW:
      PRIVATE(this)->moveCameraScreen(SbVec2f(0.1f, 0.0f));
      return TRUE;
    case SoKeyboardEvent::DOWN_ARROW:
      PRIVATE(this)->moveCameraScreen(SbVec2f(0.0f, -0.1f));
      return TRUE;
    default:
      break;
    }
  }

  if (this->isSeekMode()) {
    if (type.isDerivedFrom(SoMouseButtonEvent::getClassTypeId())) {
      SoMouseButtonEvent * const e = (SoMouseButtonEvent *) event;
      if (e->getButton() == SoMouseButtonEvent::BUTTON1) {
        if (e->getState() == SoButtonEvent::DOWN) {
          this->seekToPoint(e->getPosition());
        }
        else {
          // We got an LMB UP-event while in seek-mode, and we just
          // swallow the event.
        }
        return TRUE;
      }
    }
  }

  return FALSE;
}

// *************************************************************************

/*!
  This method is obsoleted.
*/
SbBool
SoGtkViewer::processCommonEvents(GdkEvent * event)
{
  if (this->invokeAppCB(event)) return TRUE;
  return FALSE;
}

// *************************************************************************

/*!
  This method is for setting up a superimposed scene graph on top
  of the viewer scene graph.  It will be used for adding spin-rotation
  coordinate systems, fly-viewer speed indicators and similar things.

  This method is not part of the original InventorXt API.
*/

void
SoGtkViewer::addSuperimposition(SoNode * scene)
{
  if (PRIVATE(this)->superimpositions == NULL) {
    PRIVATE(this)->superimpositions = new SbPList;
    PRIVATE(this)->superimpositionsenabled = new SbIntList;
  }
  PRIVATE(this)->searchaction->reset();
  PRIVATE(this)->searchaction->setType(SoCamera::getClassTypeId());
  PRIVATE(this)->searchaction->setInterest(SoSearchAction::FIRST);
  PRIVATE(this)->searchaction->apply(scene);
  if (!PRIVATE(this)->searchaction->isFound()) {
    // FIXME: set up default environment if there is no camera in the
    // superimposition scene
    if (SOGTK_DEBUG) {
      SoDebugError::postInfo("SoGtkViewer::addSuperimposition",
                             "cameraless superimpositions are not "
                             "supported yet");
    }
    return;
  }
  scene->ref();
  PRIVATE(this)->superimpositions->append(scene);
  PRIVATE(this)->superimpositionsenabled->append(TRUE);
} // setSuperimposedSceneGraph()

// *************************************************************************

/*!
  This method is not part of the original InventorXt API.
*/

void
SoGtkViewer::removeSuperimposition(SoNode * scene)
{
  assert(scene);
  int idx = -1;
  if (PRIVATE(this)->superimpositions == NULL) goto error;
  idx = PRIVATE(this)->superimpositions->find(scene);
  if (idx == -1) goto error;
  assert(PRIVATE(this)->superimpositionsenabled != NULL);
  PRIVATE(this)->superimpositions->remove(idx);
  PRIVATE(this)->superimpositionsenabled->remove(idx);
  scene->unref();
  return;

 error:
  if (SOGTK_DEBUG) {
    SoDebugError::post("SoGtkViewer::removeSuperimposition",
                       "no such superimposition");
  }
  return;
}

// *************************************************************************

/*!
  This method sets whether the superimposed scene graph should be traversed
  or not.

  This method is not part of the original InventorXt API.
*/

void
SoGtkViewer::setSuperimpositionEnabled(SoNode * scene,
                                         const SbBool enable)
{
  int idx = -1;
  if (PRIVATE(this)->superimpositions == NULL) goto error;
  idx = PRIVATE(this)->superimpositions->find(scene);
  if (idx == -1) goto error;
  (*PRIVATE(this)->superimpositionsenabled)[idx] = enable;
  return;

 error:
  if (SOGTK_DEBUG) {
    SoDebugError::post("SoGtkViewer::setSuperimpositionEnabled",
                       "no such superimposition");
  }
  return;
}

// *************************************************************************

/*!
  This method returns whether the superimposed scene is rendered or not.

  This method is not part of the original InventorXt API.
*/

SbBool
SoGtkViewer::getSuperimpositionEnabled(SoNode * scene) const
{
  int idx = -1;
  if (PRIVATE(this)->superimpositions == NULL) goto error;
  idx = PRIVATE(this)->superimpositions->find(scene);
  if (idx == -1) goto error;
  return (*PRIVATE(this)->superimpositionsenabled)[idx];

 error:
  if (SOGTK_DEBUG) {
    SoDebugError::post("SoGtkViewer::getSuperimpositionEnabled",
                       "no such superimposition");
  }
  return FALSE;
}

/*!  
  Returns the coordinate system the current camera is located in. If
  there are transformations before the camera in the scene graph, this
  must be considered before doing certain operations. \a matrix and \a
  inverse will not contain the transformations caused by the camera
  fields, only the transformations traversed before the camera in the
  scene graph.
*/
void 
SoGtkViewer::getCameraCoordinateSystem(SbMatrix & matrix, SbMatrix & inverse)
{
  if (this->camera && this->sceneRoot) {
    PRIVATE(this)->getCameraCoordinateSystem(this->camera, this->sceneRoot,
                                             matrix, inverse);
  }  
}

// *************************************************************************

#if SOGTK_DEBUG
static const char * getSoGtkViewerRCSId(void) { return rcsid; }
#endif // SOGTK_DEBUG
